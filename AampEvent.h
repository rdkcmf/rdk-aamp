/*
 * If not stated otherwise in this file or this component's license file the
 * following copyright and licenses apply:
 *
 * Copyright 2018 RDK Management
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
*/

/**
 * @file AampEvent.h
 * @brief Events supported by the AAMP player.
 */

#ifndef __AAMP_EVENTS_H__
#define __AAMP_EVENTS_H__

#include "vttCue.h" //Required for VTTCue
#include <memory>
#include <vector>

// Macros required for backward compatible AAMPEventListener implementation
#define MAX_LANGUAGE_COUNT 16
#define MAX_LANGUAGE_TAG_LENGTH 32 // <lang>-<role>
//(3+1+1) /* iso639-2 + optional 2..9 digit to disambiguate multiple same-language tracms, + nul terminator */

#define MAX_BITRATE_COUNT 10
#define MAX_SUPPORTED_SPEED_COUNT 11 /* [-64, -32, -16, -4, -1, 0, 1, 4, 16, 32, 64] */

/**
 * @brief Type of the events sending to the JSPP player.
 */
typedef enum
{
	AAMP_EVENT_TUNED = 1,			/**< 1,	 Tune success*/
	AAMP_EVENT_TUNE_FAILED,			/**< 2,	 Tune failure*/
	AAMP_EVENT_SPEED_CHANGED,		/**< 3,	 Speed changed internally*/
	AAMP_EVENT_EOS,				/**< 4,	End of stream*/
	AAMP_EVENT_PLAYLIST_INDEXED,		/**< 5,	Playlist downloaded and indexed*/
	AAMP_EVENT_PROGRESS,			/**< 6,	Progress event with playback stats. Report interval configurable */
	AAMP_EVENT_CC_HANDLE_RECEIVED,		/**< 7,	Sent when video decoder handle retrieved */
	AAMP_EVENT_JS_EVENT,			/**< 8, Generic event generated by JavaScript binding */
	AAMP_EVENT_MEDIA_METADATA,		/**< 9,	Meta-data of asset currently playing*/
	AAMP_EVENT_ENTERING_LIVE,		/**< 10, Event when live point reached*/
	AAMP_EVENT_BITRATE_CHANGED,		/**< 11, Event when bitrate changes */
	AAMP_EVENT_TIMED_METADATA,		/**< 12, Meta-data of a subscribed tag parsed from manifest*/
	AAMP_EVENT_BULK_TIMED_METADATA,		/**< 13, Bulk Meta-data of a subscribed tag parsed from manifest*/
	AAMP_EVENT_STATE_CHANGED,		/**< 14, Event when player state changes */
	AAMP_EVENT_SPEEDS_CHANGED,		/**< 15, Event when supported playback speeds changes */
	AAMP_EVENT_SEEKED,			/**< 16, Event when seek completes, including new position*/
	AAMP_EVENT_TUNE_PROFILING,		/**< 17, Event when micro event data sends*/
	AAMP_EVENT_BUFFERING_CHANGED,		/**< 18, Event when buffering starts/ends btw a playback*/
	AAMP_EVENT_DURATION_CHANGED,		/**< 19, Event when duration changed */
	AAMP_EVENT_AUDIO_TRACKS_CHANGED,	/**< 20, Event when available audio tracks changes */
	AAMP_EVENT_TEXT_TRACKS_CHANGED,		/**< 21, Event when available test tracks changes */
	AAMP_EVENT_AD_BREAKS_CHANGED,		/**< 22, Event when content/ad breaks changes */
	AAMP_EVENT_AD_STARTED,			/**< 23, Ad playback started */
	AAMP_EVENT_AD_COMPLETED,		/**< 24, Ad playback completed */
	AAMP_EVENT_DRM_METADATA,		/**< 25, Event with DRM metadata info*/
	AAMP_EVENT_REPORT_ANOMALY,		/**< 26, Playback Anomaly reporting */
	AAMP_EVENT_WEBVTT_CUE_DATA,		/**< 27, WebVTT Cue data */
	AAMP_EVENT_AD_RESOLVED,			/**< 28, Ad fulfill status */
	AAMP_EVENT_AD_RESERVATION_START,	/**< 29, Adbreak playback starts */
	AAMP_EVENT_AD_RESERVATION_END,		/**< 30, Adbreak playback ends */
	AAMP_EVENT_AD_PLACEMENT_START,		/**< 31, Ad playback starts */
	AAMP_EVENT_AD_PLACEMENT_END,		/**< 32, Ad playback ends */
	AAMP_EVENT_AD_PLACEMENT_ERROR,		/**< 33, Ad playback error */
	AAMP_EVENT_AD_PLACEMENT_PROGRESS,	/**< 34, Ad playback progress */
	AAMP_EVENT_REPORT_METRICS_DATA,		/**< 35, AAMP VideoEnd info reporting */
	AAMP_EVENT_ID3_METADATA,		/**< 36, ID3 metadata from audio stream */
	AAMP_EVENT_DRM_MESSAGE,         	/**< 37, Message from the DRM system */
	AAMP_EVENT_BLOCKED,         	        /**< 38, ATSC AV BLOCKED Event*/
	AAMP_EVENT_WATERMARK_SESSION_UPDATE,    /**< 39, Update on Watermark Session*/
	AAMP_EVENT_CONTENT_GAP,			/**< 40, Content gap event for progress gap reporting*/
	AAMP_MAX_NUM_EVENTS
} AAMPEventType;

/**
 * @brief AAMP playback error codes
 */
typedef enum
{
	AAMP_TUNE_INIT_FAILED,				/**< Tune failure due to initialization error*/
	AAMP_TUNE_INIT_FAILED_MANIFEST_DNLD_ERROR,	/**< Tune failure due to manifest download error*/
	AAMP_TUNE_INIT_FAILED_MANIFEST_CONTENT_ERROR,	/**< Tune failure due to manifest content error*/
	AAMP_TUNE_INIT_FAILED_MANIFEST_PARSE_ERROR,	/**< Tune failure due to manifest parse error*/
	AAMP_TUNE_INIT_FAILED_PLAYLIST_VIDEO_DNLD_ERROR,/**< Tune failure due to video playlist download error*/
	AAMP_TUNE_INIT_FAILED_PLAYLIST_AUDIO_DNLD_ERROR,/**< Tune failure due to audio playlist download error*/
	AAMP_TUNE_INIT_FAILED_TRACK_SYNC_ERROR,		/**< Tune failure due to A/V track sync error*/
	AAMP_TUNE_MANIFEST_REQ_FAILED,			/**< Tune failure caused by manifest fetch failure*/
	AAMP_TUNE_AUTHORISATION_FAILURE,		/**< Not authorised to view the content*/
	AAMP_TUNE_FRAGMENT_DOWNLOAD_FAILURE,		/**< When fragment download fails for 5 consecutive fragments*/
	AAMP_TUNE_INIT_FRAGMENT_DOWNLOAD_FAILURE,	/**< Unable to download init fragment*/
	AAMP_TUNE_UNTRACKED_DRM_ERROR,			/**< DRM error*/
	AAMP_TUNE_DRM_INIT_FAILED,			/**< DRM initialization failure */
	AAMP_TUNE_DRM_DATA_BIND_FAILED,			/**< InitData binding with DRM failed */
	AAMP_TUNE_DRM_SESSIONID_EMPTY,			/**< DRM session ID empty */
	AAMP_TUNE_DRM_CHALLENGE_FAILED,			/**< DRM key request challenge generation failed */
	AAMP_TUNE_LICENCE_TIMEOUT,			/**< DRM license request timeout */
	AAMP_TUNE_LICENCE_REQUEST_FAILED,		/**< DRM license got invalid response */
	AAMP_TUNE_INVALID_DRM_KEY,			/**< DRM reporting invalid license key */
	AAMP_TUNE_UNSUPPORTED_STREAM_TYPE,		/**< Unsupported stream type */
	AAMP_TUNE_UNSUPPORTED_AUDIO_TYPE,		/**< Unsupported audio type in manifest */
	AAMP_TUNE_FAILED_TO_GET_KEYID,			/**< Failed to parse key id from init data*/
	AAMP_TUNE_FAILED_TO_GET_ACCESS_TOKEN,		/**< Failed to get session token from AuthService*/
	AAMP_TUNE_CORRUPT_DRM_DATA,			/**< DRM failure due to corrupt drm data, self heal might clear further errors*/
	AAMP_TUNE_CORRUPT_DRM_METADATA,			/**< DRM failure due to corrupt drm metadata in the stream*/
	AAMP_TUNE_DRM_DECRYPT_FAILED,			/**< DRM Decryption Failed for Fragments */
	AAMP_TUNE_DRM_UNSUPPORTED,			/**< DRM Format Unsupported */
	AAMP_TUNE_DRM_SELF_ABORT,			/** <Download activity is aborted by player */
	AAMP_TUNE_GST_PIPELINE_ERROR,			/**< Playback failure due to error from GStreamer pipeline or associated plugins */
	AAMP_TUNE_PLAYBACK_STALLED,			/**< Playback was stalled due to valid fragments not available in playlist */
	AAMP_TUNE_CONTENT_NOT_FOUND,			/**< The resource was not found at the URL provided (HTTP 404) */
	AAMP_TUNE_DRM_KEY_UPDATE_FAILED,		/**< Failed to process DRM key, see the error code returned from Update() for more info */
	AAMP_TUNE_DEVICE_NOT_PROVISIONED,		/**< STB not provisioned/corrupted; need to re-provision. */
	AAMP_TUNE_HDCP_COMPLIANCE_ERROR,		/**< HDCP Compliance Check failure.Not compatible hdcp version for playback */
	AAMP_TUNE_INVALID_MANIFEST_FAILURE,		/**< Manifest is invalid */
	AAMP_TUNE_FAILED_PTS_ERROR,			/**< Playback failed due to PTS error */
	AAMP_TUNE_MP4_INIT_FRAGMENT_MISSING,		/**< Init fragments missing in playlist */
	AAMP_TUNE_FAILURE_UNKNOWN			/**<  Unknown failure */
} AAMPTuneFailure;

/**
 * @brief  Mapping all required status codes based on JS player requirement. These requirements may be
 * forced by psdk player.AAMP may not use all the statuses mentioned below:
 * Mainly required states - idle, initializing, initialized, preparing, prepared, playing, paused, seek, complete and error
 */
typedef enum
{
	eSTATE_IDLE,         /**< 0  - Player is idle */
	eSTATE_INITIALIZING, /**< 1  - Player is initializing a particular content */
	eSTATE_INITIALIZED,  /**< 2  - Player has initialized for a content successfully */
	eSTATE_PREPARING,    /**< 3  - Player is loading all associated resources */
	eSTATE_PREPARED,     /**< 4  - Player has loaded all associated resources successfully */
	eSTATE_BUFFERING,    /**< 5  - Player is in buffering state */
	eSTATE_PAUSED,       /**< 6  - Playback is paused */
	eSTATE_SEEKING,      /**< 7  - Seek is in progress */
	eSTATE_PLAYING,      /**< 8  - Playback is in progress */
	eSTATE_STOPPING,     /**< 9  - Player is stopping the playback */
	eSTATE_STOPPED,      /**< 10 - Player has stopped playback successfully */
	eSTATE_COMPLETE,     /**< 11 - Playback completed */
	eSTATE_ERROR,        /**< 12 - Error encountered and playback stopped */
	eSTATE_RELEASED,     /**< 13 - Player has released all resources for playback */
	eSTATE_BLOCKED       /**< 14 - Player has blocked and cant play content*/
} PrivAAMPState;

/**
 * @brief AAMP metric data types
 */
typedef enum E_MetricsDataType
{
	AAMP_DATA_NONE,
	AAMP_DATA_VIDEO_END
} MetricsDataType;

/**
 * @enum Video Scan Type
 *
 * @brief Video Scan Type - Progressive/Interlaced
 * */
typedef enum
{
	eVIDEOSCAN_PROGRESSIVE,
	eVIDEOSCAN_INTERLACED,
	eVIDEOSCAN_UNKNOWN
}VideoScanType;

/**
 * @brief Structure of the AAMP events.
 * Recommend new AAMP integration layers to use AAMPEventObject based listener
 * For new event definition, should use AAMPEventObject class
 * TODO: Deperecate in future, kept for backward compatibility only
 */
struct AAMPEvent
{
	AAMPEventType type; 		/**< Event type */

	union
	{
		struct
		{
			int severity; /**< informative number indicates severity of msg, e.g Warning, Error, Trace etc */
			const char *msg;
		} anomalyReport;

		struct
		{
			const char *microData;   /**< micro event data for profiling */
		} tuneProfile;

		struct
		{
			MetricsDataType type; 		/**< type of data , e.g AAMP_DATA_VIDEO_END for VideoEndEvent data */
			const char *metricUUID;         /**< unique session id passed during tune */
			const char *data;               /**< data for event  */
		} metricsData;

		/**
		 * @brief Structure of the progress event data
		 */
		struct
		{
			double durationMiliseconds; /**< current size of time shift buffer */
			double positionMiliseconds; /**< current play/pause position relative to tune time - starts at zero) */
			float playbackSpeed;        /**< current trick speed (1.0 for normal play rate) */
			double startMiliseconds;    /**< time shift buffer start position (relative to tune time - starts at zero) */
			double endMiliseconds;      /**< time shift buffer end position (relative to tune time - starts at zero) */
			long long videoPTS; 		/**< Video Presentation 90 Khz time-stamp  */
			double videoBufferedMiliseconds;	/**< current duration of buffered video ready to playback */
			const char* timecode;		/**< SEI Timecode information */
		} progress;

		/**
		 * @brief Structure of the seeked event data
		 */
		struct
		{
			double positionMiliseconds;	/**< new seeked position in milliseconds */
		} seeked;

		/**
		 * @brief Structure of the speed change event
		 */
		struct
		{
			int rate; /**< Playback rate */
		} speedChanged;

		/**
		 * @brief Structure of the bitrate change event
		 */
		struct
		{
			int time;                   /**< Playback time */
			long bitrate;               /**< Playback bitrate */
			const char *description;    /**< Description */
			int width;                  /**< Video width */
			int height;                 /**< Video height */
			double framerate;           /**< FrameRate */
			double position;            /**< bitrate changed position*/
			bool cappedProfile;         /**< profile capped status*/
			int displayWidth;	    /**< output display width*/
			int displayHeight;	    /**< output display height*/
			VideoScanType videoScanType;/**< video scan type*/
			int aspectRatioWidth;	    /**< aspect ratio width*/
			int aspectRatioHeight;	    /**< aspect ratio height*/
		} bitrateChanged;

		/**
		 * @brief Structure of the metadata event
		 */
		struct
		{
			long durationMiliseconds;                                       /**< Asset duration */
			int languageCount;                                              /**< Available language count */
			char languages[MAX_LANGUAGE_COUNT][MAX_LANGUAGE_TAG_LENGTH];    /**< Available languages */
			int bitrateCount;                                               /**< Available bitrate count */
			long bitrates[MAX_BITRATE_COUNT];                               /**< Available bitrates */
			int width;                                                      /**< Maximum video width */
			int height;                                                     /**< Maximum video height */
			bool hasDrm;                                                    /**< Drm enabled */
			int supportedSpeedCount;                                        /**< Supported playback speed count */
			int supportedSpeeds[MAX_SUPPORTED_SPEED_COUNT];                 /**< Supported playback speeds */
		} metadata;

		/**
		 * @brief Structure of the closed caption handle event
		 */
		struct
		{
			unsigned long handle;	/**< Closed caption handle */
		} ccHandle;

		/**
		 * @brief Structure of the timed metadata event
		 */
		struct
		{
			const char* szName;         /**< Metadata name */
			const char* id;             /**< Id of the timedMetadata */
			long long timeMilliseconds; /**< Playback position - relative to tune time - starts at zero */
			double durationMilliSeconds;/**< Duration of the timed event. */
			const char* szContent;      /**< Metadata content */
		} timedMetadata;

		/**
		 * @brief Structure of the bulk timed metadata event
		 */
		struct
		{
			const char* szMetaContent;      /**< Metadata content */
		} bulktimedMetadata;

		/**
		 * @brief Structure of the Java Script event
		 */
		struct
		{
			const char* szEventType;    /**< Event Type */
			void*  jsObject;            /**< Pointer to the Java Scipt Object */
		} jsEvent;

		/**
		 * @brief Structure of the media error event
		 */
		struct
		{
			AAMPTuneFailure failure;                            /**< Error Type */
			int code;                                           /**< Error code */
			const char *description;                            /**< Error description */
			bool shouldRetry;                                   /**< If recovery on retry is possible */
		} mediaError;

		struct
		{
			AAMPTuneFailure failure;                            /**< Error Type */
			const char *accessStatus;
			int accessStatus_value;
			long responseCode;
			bool isSecClientError;
		} dash_drmmetadata;

		/**
		 * @brief Structure of the player state changed event
		 */
		struct
		{
			PrivAAMPState state;        /**< Player state */
		} stateChanged;

		/**
		 * @brief Structure of the buffering changed event
		 */
		struct
		{
			bool buffering;            /**< true if buffering started, false otherwise */
		} bufferingChanged;

		/**
		 * @brief Structure of the supported speeds changed event
		 */
		struct
		{
			int supportedSpeedCount;                            /**< Supported playback speed count */
			int supportedSpeeds[MAX_SUPPORTED_SPEED_COUNT];     /**< Supported playback speeds */
		} speedsChanged;

		/**
		 * @brief Structure of the WebVTT cue data
		 */
		struct
		{
			VTTCue* cueData;
		} cue;

		/**
		 * @brief Structure for ad fulfill status event
		 */
		struct
		{
			bool resolveStatus;
			const char *adId;
			uint64_t startMS;
			uint64_t durationMs;
		} adResolved;

		/**
		 * @brief Structure for ad reservation events
		 */
		struct
		{
			const char *adBreakId;     /**< Reservation Id */
			uint64_t position;
		} adReservation;

		/**
		 * @brief Structure for ad placement events
		 */
		struct
		{
			const char *adId;		/**< Placement Id */
			uint32_t position;		/**<Ad Position relative to Reservation Start */
			uint32_t offset;		/**<Ad start offset */
			uint32_t duration;
			int errorCode;
		} adPlacement;

		/** @brief Structure of the id3 metadata event
		 */
		struct
		{
			uint8_t *data;   	 /**< Data pointer to ID3 metadata blob */
			int32_t length;		/**< Length of the ID3 metadata blob */
		} id3Metadata;

		struct
		{
			const char *data;
		} drmMessage;

		struct
		{
			long long timeMilliseconds;		/**< Playback position - relative to tune time - starts at zero */
			double durationMilliSeconds;	/**< Duration of the gap */
		} contentGap;

	} data;

	/**
	 * @brief AAMPEvent Constructor
	 */
	AAMPEvent() : type(AAMP_MAX_NUM_EVENTS), data()
	{

	}

	/**
	 * @brief AAMPEvent Constructor
	 *
	 * @param[in]  Event type
	 */
	AAMPEvent(AAMPEventType t) : type(t), data()
	{

	}

	AAMPEvent(const AAMPEvent&) = delete;
	AAMPEvent& operator=(const AAMPEvent&) = delete;
};

/**
 * @brief Base class of all AAMP events.
 * New AAMP event object for ease of use
 * While defining new event objects inherit from this base class
 */
class AAMPEventObject
{
	AAMPEventType mType;		/**< Event type */

public:

	AAMPEventObject() = delete;
	AAMPEventObject(const AAMPEventObject&) = delete;
	AAMPEventObject& operator=(const AAMPEventObject&) = delete;

	/**
	 * @brief AAMPEvent Constructor
	 */
	AAMPEventObject(AAMPEventType type);

	/**
	 * @brief AAMPEvent Destructor
	 */
	virtual ~AAMPEventObject() { }

	/**
	 * @brief Get Event Type
	 *
	 * @return Event Type
	 */
	AAMPEventType getType() const;
};

/**
 * @brief Class for the Media Error event
 */
class MediaErrorEvent: public AAMPEventObject
{
	AAMPTuneFailure mFailure;	/**< Error Type */
	int mCode;			/**< Error code */
	std::string mDescription;	/**< Error description */
	bool mShouldRetry;		/**< If recovery on retry is possible */

public:
	MediaErrorEvent() = delete;
	MediaErrorEvent(const MediaErrorEvent&) = delete;
	MediaErrorEvent& operator=(const MediaErrorEvent&) = delete;

	/*
	 * @brief MediaErrorEvent Constructor
	 *
	 * @param[in] failure     - Failure type
	 * @param[in] code        - Error code
	 * @param[in] desc        - Error description
	 * @param[in] shouldRetry - Retry or not
	 */
	MediaErrorEvent(AAMPTuneFailure failure, int code, const std::string &desc, bool shouldRetry);

	/**
	 * @brief MediaErrorEvent Destructor
	 */
	virtual ~MediaErrorEvent() { }

	/**
	 * @brief Get Failure Type
	 *
	 * @return Tune failure type
	 */
	AAMPTuneFailure getFailure() const;

	/**
	 * @brief Get Error Code
	 *
	 * @return Tune error code
	 */
	int getCode() const;

	/**
	 * @brief Get Description
	 *
	 * @return Error description
	 */
	const std::string &getDescription() const;

	/**
	 * @brief Retry or not
	 *
	 * @return Retry or don't retry
	 */
	bool shouldRetry() const;
};

/**
 * @brief Class for the Speed changed event
 */
class SpeedChangedEvent: public AAMPEventObject
{
	int mRate;		/**< Playback rate */

public:
	SpeedChangedEvent() = delete;
	SpeedChangedEvent(const SpeedChangedEvent&) = delete;
	SpeedChangedEvent& operator=(const SpeedChangedEvent&) = delete;

	/*
	 * @brief SpeedChangedEvent Constructor
	 *
	 * @param[in]  rate - New speed
	 */
	SpeedChangedEvent(int rate);

	/**
	 * @brief SpeedChangedEvent Destructor
	 */
	virtual ~SpeedChangedEvent() { }

	/**
	 * @brief Get Rate
	 *
	 * @return New speed
	 */
	int getRate() const;
};

/**
 * @brief Class for the Progress event
 */
class ProgressEvent: public AAMPEventObject
{
	double mDuration;		/**< current size of time shift buffer in MS*/
	double mPosition;		/**< current play/pause position relative to tune time - starts at zero) in MS */
	double mStart;			/**< time shift buffer start position (relative to tune time - starts at zero) in MS */
	double mEnd;			/**< time shift buffer end position (relative to tune time - starts at zero) in MS */
	float mSpeed;			/**< current trick speed (1.0 for normal play rate) */
	long long mPTS;			/**< Video Presentation 90 Khz time-stamp  */
	double mBufferedDuration;	/**< current duration of buffered video ready to playback */
	std::string mSEITimecode;       /**< SEI Timecode information */

public:
	ProgressEvent() = delete;
	ProgressEvent(const ProgressEvent&) = delete;
	ProgressEvent& operator=(const ProgressEvent&) = delete;

	/*
	 * @brief ProgressEvent Constructor
	 *
	 * @param[in]  duration - Duration of Asset
	 * @param[in]  position - Current Position
	 * @param[in]  start    - Start Position
	 * @param[in]  end      - End Position
	 * @param[in]  speed    - Current Speed
	 * @param[in]  pts      - Video PTS
	 * @param[in]  bufferedDuration - buffered duration
	 */
	ProgressEvent(double duration, double position, double start, double end, float speed, long long pts, double bufferedDuration, std::string seiTimecode);

	/**
	 * @brief ProgressEvent Destructor
	 */
	virtual ~ProgressEvent() { }

	/**
	 * @brief Get Duration of Asset
	 *
	 * @return Asset duration in MS
	 */
	double getDuration() const;

	/**
	 * @brief Get Current Position
	 *
	 * @return Current position in MS
	 */
	double getPosition() const;

	/**
	 * @brief Get Start Position
	 *
	 * @return Start position in MS
	 */
	double getStart() const;

	/**
	 * @brief Get End Position
	 *
	 * @return End position in MS
	 */
	double getEnd() const;

	/**
	 * @brief Get Speed
	 *
	 * @return Current speed
	 */
	float getSpeed() const;

	/**
	 * @brief Get Video PTS
	 *
	 * @return Video PTS
	 */
	long long getPTS() const;

	/**
	 * @brief Get Buffered Duration
	 *
	 * @return Buffered duration
	 */
	double getBufferedDuration() const;

	/**
	* @brief Get SEI Time Code
	*
	* @return SEI Time Code
	*/
	const char* getSEITimeCode() const;
};

/**
 * @brief Class for the Closed Caption Handle event
 */
class CCHandleEvent: public AAMPEventObject
{
	unsigned long mHandle;		/**< Closed caption handle */

public:
	CCHandleEvent() = delete;
	CCHandleEvent(const CCHandleEvent&) = delete;
	CCHandleEvent& operator=(const CCHandleEvent&) = delete;

	/*
	 * @brief CCHandleEvent Constructor
	 *
	 * @param[in] handle - Handle to close caption
	 */
	CCHandleEvent(unsigned long handle);

	/**
	 * @brief CCHandleEvent Destructor
	 */
	virtual ~CCHandleEvent() { }

	/**
	 * @brief Get Closed Caption Handle
	 *
	 * @return Handle to the closed caption
	 */
	unsigned long getCCHandle() const;
};

/**
 * @brief Class for the Media Metadata event
 */
class MediaMetadataEvent: public AAMPEventObject
{
	long mDuration;				/**< Asset duration in MS */
	std::vector<std::string> mLanguages;	/**< Available languages */
	std::vector<long> mBitrates;		/**< Available bitrates */
	int mWidth;				/**< Maximum video width */
	int mHeight;				/**< Maximum video height */
	bool mHasDrm;				/**< Drm enabled */
	std::vector<int> mSupportedSpeeds;	/**< Supported playback speeds */
	bool mIsLive;				/**< Is Live */
	std::string mDrmType;			/**< DRM type */

public:
	MediaMetadataEvent() = delete;
	MediaMetadataEvent(const MediaMetadataEvent&) = delete;
	MediaMetadataEvent& operator=(const MediaMetadataEvent&) = delete;

	/*
	 * @brief MediaMetadataEvent Constructor
	 *
	 * @param[in] duration - Duration of Media Metadata
	 * @param[in] width    - Video width
	 * @param[in] height   - Video height
	 * @param[in] hasDrm   - Drm enablement status
	 * @param[in] isLive   - Is Live
	 * @param[in] DrmType  - DRM Type
	 */
	MediaMetadataEvent(long duration, int width, int height, bool hasDrm, bool isLive, const std::string &DrmType);

	/**
	 * @brief MediaMetadataEvent Destructor
	 */
	virtual ~MediaMetadataEvent() { }

	/**
	 * @brief Get Duration
	 *
	 * @return Asset duration
	 */
	long getDuration() const;

	/**
	 * @brief Add a supported language
	 *
	 * @param[in] lang - Supported language
	 * @return void
	 */
	void addLanguage(const std::string &lang);

	/**
	 * @brief Get Languages
	 *
	 * @return Vector of supported languages
	 */
	const std::vector<std::string> &getLanguages() const;

	/**
	 * @brief Get Language Count
	 *
	 * @return Supported language count
	 */
	int getLanguagesCount() const;

	/**
	 * @brief Add a supported bitrate
	 *
	 * @param[in] bitrate - Supported bitrate
	 * @return void
	 */
	void addBitrate(long bitrate);

	/**
	 * @brief Get Bitrates
	 *
	 * @return Vector of supported bitrates
	 */
	const std::vector<long> &getBitrates() const;

	/**
	 * @brief Get Bitrate Count
	 *
	 * @return Supported bitrate count
	 */
	int getBitratesCount() const;

	/**
	 * @brief Get Width
	 *
	 * @return Video width
	 */
	int getWidth() const;

	/**
	 * @brief Get Height
	 *
	 * @return Video height
	 */
	int getHeight() const;

	/**
	 * @brief Supports DRM or not
	 *
	 * @return DRM enablement status
	 */
	bool hasDrm() const;

	/**
	 * @brief Check for Live content or VOD
	 *
	 * @return isLive
	 */
	bool isLive() const;

	/**
	 * @brief Get Current DRM Type
	 *
	 * @return Current DRM
	 */
	const std::string &getDrmType() const;

	/**
	 * @brief Add a supported speed
	 *
	 * @param[in] speed - Supported speed
	 * @return void
	 */
	void addSupportedSpeed(int speed);

	/**
	 * @brief Get Supported Speeds
	 *
	 * @return Vector of supported speeds
	 */
	const std::vector<int> &getSupportedSpeeds() const;

	/**
	 * @brief Get Supported Speed count
	 *
	 * @return Supported speeds count
	 */
	int getSupportedSpeedCount() const;
};

/**
 * @brief Class for the Bitrate change event
 */
class BitrateChangeEvent: public AAMPEventObject
{
	int mTime;			/**< Playback time */
	long mBitrate;			/**< Playback bitrate */
	std::string mDescription;	/**< Bitrate change reason */
	int mWidth;			/**< Video width */
	int mHeight;			/**< Video height */
	double mFrameRate;		/**< FrameRate */
	double mPosition;		/**< Position at which bitrate changed */
	bool mCappedProfile;  	        /**< Capped/Restricted profile status */
	int mDisplayWidth;		/**< TV display width */
	int mDisplayHeight;		/**< TV display height */
	VideoScanType mVideoScanType;   /**< Video Scan Type progressive/interlaced */
	int mAspectRatioWidth;		/**< Aspect Ratio Width*/
	int mAspectRatioHeight;		/**< Aspect Ratio Height*/

public:
	BitrateChangeEvent() = delete;
	BitrateChangeEvent(const BitrateChangeEvent&) = delete;
	BitrateChangeEvent& operator=(const BitrateChangeEvent&) = delete;

	/*
	 * @brief BitrateChangeEvent Constructor
	 *
	 * @param[in] time       - Time of bitrate change
	 * @param[in] bitrate    - New bitrate
	 * @param[in] desc       - Reason of change
	 * @param[in] width      - Video width
	 * @param[in] height     - Video height
	 * @param[in] frameRate  - Framerate
	 * @param[in] position   - Position
	 * @param[in] cappedProfile - Profile capping status
	 * @param[in] displayWidth - Output tv display width
	 * @param[in] displayHeight - Output tv dispay height
	 * @param[in] videoScanType   - Video Scan Type
	 * @param[in] position   - Aspect Ratio Width
	 * @param[in] position   - Aspect Ratio Height
	 */
	BitrateChangeEvent(int time, long bitrate, const std::string &desc, int width, int height, double frameRate, double position, bool mCappedProfile, int mDisplayWidth, int mDisplayHeight, VideoScanType videoScanType, int aspectRatioWidth, int aspectRatioHeight);

	/**
	 * @brief BitrateChangeEvent Destructor
	 */
	virtual ~BitrateChangeEvent() { }

	/**
	 * @brief Get Time
	 *
	 * @return Playback time
	 */
	int getTime() const;

	/**
	 * @brief Get Bitrate
	 *
	 * @return Current bitrate
	 */
	long getBitrate() const;

	/**
	 * @brief Get Description
	 *
	 * @return Reason of bitrate change
	 */
	const std::string &getDescription() const;

	/**
	 * @brief Get Width
	 *
	 * @return Video width
	 */
	int getWidth() const;

	/**
	 * @brief Get Height
	 *
	 * @return Video height
	 */
	int getHeight() const;

	/**
	 * @brief Get Frame Rate
	 *
	 * @return Frame Rate
	 */
	double getFrameRate() const;

	/**
	 * @brief Get Position
	 *
	 * @return Position
	 */
	double getPosition() const;

	 /**
         * @brief Get Capped Profile status
         *
         * @return profile filterting restricted status
         */
        bool getCappedProfileStatus() const;

	 /**
         * @brief Get display width
         *
         * @return output display tv width
         */
        int getDisplayWidth() const;

	 /**
         * @brief Get display Height
         *
         * @return output display tv height
         */
        int getDisplayHeight() const;

	 /**
	 * @brief Get Video Scan Type
	 *
	 * @return output video scan type
	 */
	VideoScanType getScanType() const;
	 /**
	 * @brief Get Aspect Ratio Width
	 *
	 * @return output aspect ratio width
	 */
	int getAspectRatioWidth() const;
	 /**
	 * @brief Get Aspect Ratio Height
	 *
	 * @return output Aspect Ratio Height
	 */
	int getAspectRatioHeight() const;
};

/**
 * @brief Class for the Timed Metadata event
 */
class TimedMetadataEvent: public AAMPEventObject
{
	std::string mName;		/**< Metadata name */
	std::string mId;		/**< Id of the timedMetadata */
	double mTime;			/**< Playback position in MS- relative to tune time - starts at zero */
	double mDuration;		/**< Duration of the timed event in MS */
	std::string mContent;		/**< Metadata content */

public:
	TimedMetadataEvent() = delete;
	TimedMetadataEvent(const TimedMetadataEvent&) = delete;
	TimedMetadataEvent& operator=(const TimedMetadataEvent&) = delete;

	/*
	 * @brief TimedMetadataEvent Constructor
	 *
	 * @param[in] name      - TimedMetadata name
	 * @param[in] id        - TimedMetadata id
	 * @param[in] time      - Time of event
	 * @param[in] duration   - Duration of event
	 * @param[in] content   - Content field of the TimedMetadata
	 */
	TimedMetadataEvent(const std::string &name, const std::string &id, double time, double duration, const std::string &content);

	/**
	 * @brief TimedMetadataEvent Destructor
	 */
	virtual ~TimedMetadataEvent() { }

	/**
	 * @brief Get Timed Metadata Name
	 *
	 * @return TimedMetadata name string
	 */
	const std::string &getName() const;

	/**
	 * @brief Get Timed Metadata Id
	 *
	 * @return TimedMetadata id string
	 */
	const std::string &getId() const;

	/**
	 * @brief Get Time
	 *
	 * @return Time of the Timed Metadata
	 */
	double getTime() const;

	/**
	 * @brief Get Duration
	 *
	 * @return Duration (in MS) of the TimedMetadata
	 */
	double getDuration() const;

	/**
	 * @brief Get Content
	 *
	 * @return Content field of the TimedMetadata
	 */
	const std::string &getContent() const;
};

/**
 * @brief Class for the Bulk TimedMetadata Event
 */
class BulkTimedMetadataEvent: public AAMPEventObject
{
	std::string mContent;		/**< Metadata content */

public:
	BulkTimedMetadataEvent() = delete;
	BulkTimedMetadataEvent(const BulkTimedMetadataEvent&) = delete;
	BulkTimedMetadataEvent& operator=(const BulkTimedMetadataEvent&) = delete;

	/*
	 * @brief BulkTimedMetadataEvent Constructor
	 *
	 * @param[in] content - metadata serialized in JSON format
	 */
	BulkTimedMetadataEvent(const std::string &content);

	/**
	 * @brief BulkTimedMetadataEvent Destructor
	 */
	virtual ~BulkTimedMetadataEvent() { }

	/**
	 * @brief Get metadata content
	 *
	 * @return metadata content
	 */
	const std::string &getContent() const;
};

/**
 * @brief Class for the Player State Changed event
 */
class StateChangedEvent: public AAMPEventObject
{
	PrivAAMPState mState;	/**< Player state */

public:
	StateChangedEvent() = delete;
	StateChangedEvent(const StateChangedEvent&) = delete;
	StateChangedEvent& operator=(const StateChangedEvent&) = delete;

	/*
	 * @brief StateChangedEvent Constructor
	 *
	 * @param[in] state - New player state
	 */
	StateChangedEvent(PrivAAMPState state);

	/**
	 * @brief StateChangedEvent Destructor
	 */
	virtual ~StateChangedEvent() { }

	/**
	 * @brief Get Current Player State
	 *
	 * @return Player state
	 */
	PrivAAMPState getState() const;
};

/**
 * @brief Class for the supported speeds changed event
 */
class SupportedSpeedsChangedEvent: public AAMPEventObject
{
	std::vector<int> mSupportedSpeeds;     /**< Supported playback speeds */

public:
	SupportedSpeedsChangedEvent(const SupportedSpeedsChangedEvent&) = delete;
	SupportedSpeedsChangedEvent& operator=(const SupportedSpeedsChangedEvent&) = delete;

	/*
	 * @brief SupportedSpeedsChangedEvent Constructor
	 */
	SupportedSpeedsChangedEvent();

	/*
	 * @brief SupportedSpeedsChangedEvent Destructor
	 */
	virtual ~SupportedSpeedsChangedEvent() { }

	/**
	 * @brief Add a Supported Speed
	 *
	 * @param[in] speed - Speed
	 * @return void
	 */
	void addSupportedSpeed(int speed);

	/**
	 * @brief Get Supported Speeds
	 *
	 * @return Vector of supported speeds
	 */
	const std::vector<int> &getSupportedSpeeds() const;

	/**
	 * @brief Get Supported Speeds Count
	 *
	 * @return Supported speeds count
	 */
	int getSupportedSpeedCount() const;
};

/**
 * @brief Class for the Seeked Event
 */
class SeekedEvent: public AAMPEventObject
{
	double mPosition;		/**< new seeked position in milliseconds */

public:
	SeekedEvent() = delete;
	SeekedEvent(const SeekedEvent&) = delete;
	SeekedEvent& operator=(const SeekedEvent&) = delete;

	/*
	 * @brief SeekedEvent Constructor
	 *
	 * @param[in] positionMS - seeked position in milliseconds
	 */
	SeekedEvent(double positionMS);

	/**
	 * @brief SeekedEvent Destructor
	 */
	virtual ~SeekedEvent() { }

	/**
	 * @brief Get position
	 *
	 * @return Seeked position
	 */
	double getPosition() const;
};

/**
 * @brief Class for the Tune Profilng Event
 */
class TuneProfilingEvent: public AAMPEventObject
{
	std::string mProfilingData;	/**< micro event data for profiling */

public:
	TuneProfilingEvent() = delete;
	TuneProfilingEvent(const TuneProfilingEvent&) = delete;
	TuneProfilingEvent& operator=(const TuneProfilingEvent&) = delete;

	/*
	 * @brief TuneProfilingEvent Constructor
	 *
	 * @param[in] profilingData - tune profiling data
	 */
	TuneProfilingEvent(std::string &profilingData);

	/**
	 * @brief TuneProfilingEvent Destructor
	 */
	virtual ~TuneProfilingEvent() { }

	/**
	 * @brief Get Tune profiling data
	 *
	 * @return Tune profiling data
	 */
	const std::string &getProfilingData() const;
};

/**
 * @brief Class for the Buffering Changed event
 */
class BufferingChangedEvent: public AAMPEventObject
{
	bool mBuffering;	/**< true if buffering started, false otherwise */

public:
	BufferingChangedEvent() = delete;
	BufferingChangedEvent(const BufferingChangedEvent&) = delete;
	BufferingChangedEvent& operator=(const BufferingChangedEvent&) = delete;

	/*
	 * @brief BufferingChangedEvent Constructor
	 *
	 * @param[in] buffering - Buffering status
	 */
	BufferingChangedEvent(bool buffering);

	/*
	 * @brief BufferingChangedEvent Destructor
	 */
	virtual ~BufferingChangedEvent() { }

	/**
	 * @brief Get Buffering Status
	 *
	 * @return Buffering status (true/false)
	 */
	bool buffering() const;
};

/**
 * @brief Class for the Drm Metadata event
 */
class DrmMetaDataEvent: public AAMPEventObject
{
	AAMPTuneFailure mFailure;	/**< Error Type */
	std::string mAccessStatus;	/**< Access status */
	int mAccessStatusValue;		/**< Access status value */
	long mResponseCode;		/**< Response code */
	bool mSecclientError;		/**< Is secclient error */

public:
	DrmMetaDataEvent() = delete;
	DrmMetaDataEvent(const DrmMetaDataEvent&) = delete;
	DrmMetaDataEvent& operator=(const DrmMetaDataEvent&) = delete;

	/*
	 * @brief DrmMetaDataEvent Constructor
	 *
	 * @param[in] failure      - Failure type
	 * @param[in] accessStatus - Access status
	 * @param[in] statusValue  - Access status value
	 * @param[in] responseCode - Response code
	 * @param[in] secclientErr - Is secclient error
	 */
	DrmMetaDataEvent(AAMPTuneFailure failure, const std::string &accessStatus, int statusValue, long responseCode, bool secclientErr);

	/**
	 * @brief DrmMetaDataEvent Destructor
	 */
	virtual ~DrmMetaDataEvent() { }

	/**
	 * @brief Get Failure type
	 *
	 * @return Tune failure type
	 */
	AAMPTuneFailure getFailure() const;

	/**
	 * @brief Set Failure type
	 *
	 * @param[in] failure - Failure type
	 * @return void
	 */
	void setFailure(AAMPTuneFailure failure);

	/**
	 * @brief Get Access Status
	 *
	 * @return Access status string
	 */
	const std::string &getAccessStatus() const;

	/**
	 * @brief Set Access Status
	 *
	 * @param[in] status - Access status
	 * @return void
	 */
	void setAccessStatus(const std::string &status);

	/**
	 * @brief Get Access Status
	 *
	 * @return Access status value
	 */
	int getAccessStatusValue() const;

	/**
	 * @brief Set Access Status Value
	 *
	 * @param[in] value - Access status value
	 * @return void
	 */
	void setAccessStatusValue(int value);

	/**
	 * @brief Get Response Code
	 *
	 * @return Response code
	 */
	long getResponseCode() const;

	/**
	 * @brief Set Response Code
	 *
	 * @param[in] code - Response code
	 * @return void
	 */
	void setResponseCode(long code);

	/**
	 * @brief Get secclient error status
	 *
	 * @return secclient error (true/false)
	 */
	bool getSecclientError() const;
       
        /**
         * @brief Set secclient error status
         *
         * @param[in] sec client error status (true/false)
         * @return void
         */
        void setSecclientError(bool secclientError);

};

/**
 * @brief Class for the Anomaly Report Event.
 */
class AnomalyReportEvent: public AAMPEventObject
{
	int mSeverity;			/**< informative number indicates severity of msg, e.g Warning, Error, Trace etc */
	std::string mMsg;		/**< Anomaly message */

public:
	AnomalyReportEvent() = delete;
	AnomalyReportEvent(const AnomalyReportEvent&) = delete;
	AnomalyReportEvent& operator=(const AnomalyReportEvent&) = delete;

	/**
	 * @brief AnomalyReportEvent Constructor
	 *
	 * @param[in]  severity - Severity of message
	 * @param[in]  msg      - Anomaly message
	 */
	AnomalyReportEvent(int severity, const std::string &msg);

	/**
	 * @brief AnomalyReportEvent Destructor
	 */
	virtual ~AnomalyReportEvent() { }

	/**
	 * @brief Get Severity
	 *
	 * @return Severity value
	 */
	int getSeverity() const;

	/**
	 * @brief Get Anomaly Message
	 *
	 * @return Anomaly message string
	 */
	const std::string &getMessage() const;
};

/**
 * @brief Class for the Web VTT Cue Event
 */
class WebVttCueEvent: public AAMPEventObject
{
	VTTCue* mCueData;	/**< Web VTT cue data */

public:
	WebVttCueEvent() = delete;
	WebVttCueEvent(const WebVttCueEvent&) = delete;
	WebVttCueEvent& operator=(const WebVttCueEvent&) = delete;

	/*
	 * @brief WebVttCueEvent Constructor
	 *
	 * @param[in] cueData - Pointer to VTT cue data
	 */
	WebVttCueEvent(VTTCue* cueData);

	/**
	 * @brief WebVttCueEvent Destructor
	 */
	virtual ~WebVttCueEvent() { }

	/**
	 * @brief Get VTT Cue Data
	 *
	 * @return Pointer to VTT cue data
	 */
	VTTCue* getCueData() const;
};

/**
 * @brief Class for ad fulfill status event
 */
class AdResolvedEvent: public AAMPEventObject
{
	bool mResolveStatus;	/**<Ad resolve status */
	std::string mAdId;	/**<Ad identifier */
	uint64_t mStartMS;	/**<Ad's start position in MS */
	uint64_t mDurationMs;	/**<Ad's duration in MS */

public:
	AdResolvedEvent() = delete;
	AdResolvedEvent(const AdResolvedEvent&) = delete;
	AdResolvedEvent& operator=(const AdResolvedEvent&) = delete;

	/*
	 * @brief AdResolvedEvent Constructor
	 *
	 * @param[in] resolveStatus - Ad resolve status
	 * @param[in] adId          - Identifier of the Ad
	 * @param[in] startMS       - Start position of Ad (relative to reservation start)
	 * @param[in] durationMs    - Duration of the Ad in MS
	 */
	AdResolvedEvent(bool resolveStatus, const std::string &adId, uint64_t startMS, uint64_t durationMs);

	/**
	 * @brief AdResolvedEvent Destructor
	 */
	virtual ~AdResolvedEvent() { }

	/**
	 * @brief Get Resolve Status
	 *
	 * @return Ad resolve status
	 */
	bool getResolveStatus() const;

	/**
	 * @brief Get Ad Identifier
	 *
	 * @return Ad's identifier
	 */
	const std::string &getAdId() const;

	/**
	 * @brief Get Start Positon
	 *
	 * @return Start position (in MS), relative to Adbreak
	 */
	uint64_t getStart() const;

	/**
	 * @brief Get Duration
	 *
	 * @return Ad's duration in MS
	 */
	uint64_t getDuration() const;

};

/**
 * @brief Class for ad reservation events
 */
class AdReservationEvent: public AAMPEventObject
{
	std::string mAdBreakId;	/**<Adbreak's id */
	uint64_t mPosition;	/**<Adbreak's start position */

public:
	AdReservationEvent() = delete;
	AdReservationEvent(const AdReservationEvent&) = delete;
	AdReservationEvent& operator=(const AdReservationEvent&) = delete;

	/*
	 * @brief AdReservationEvent Constructor
	 *
	 * @param[in] evtType  - Event Type
	 * @param[in] breakId  - Unique identifier of Ad reservation.
	 * @param[in] position - Postion of reservation in content's PTS
	 */
	AdReservationEvent(AAMPEventType evtType, const std::string &breakId, uint64_t position);

	/**
	 * @brief AdReservationEvent Destructor
	 */
	virtual ~AdReservationEvent() { }

	/**
	 * @brief Get Adbreak Identifier
	 *
	 * @return Adbreak's id
	 */
	const std::string &getAdBreakId() const;

	/**
	 * @brief Get Ad's Position
	 *
	 * @return Ad's position (in channel's PTS)
	 */
	uint64_t getPosition() const;
};

/**
 * @brief Class for ad placement events
 */
class AdPlacementEvent: public AAMPEventObject
{
	std::string mAdId;	/**<Ad Id */
	uint32_t mPosition;	/**<Ad Position relative to Reservation Start */
	uint32_t mOffset;	/**<Ad start offset */
	uint32_t mDuration;	/**<Ad's duration */
	int mErrorCode;		/**<Error code, if any */

public:
	AdPlacementEvent() = delete;
	AdPlacementEvent(const AdPlacementEvent&) = delete;
	AdPlacementEvent& operator=(const AdPlacementEvent&) = delete;

	/*
	 * @brief AdPlacementEvent Constructor
	 *
	 * @param[in] evtType   - Event type
	 * @param[in] adId      - Ad Id
	 * @param[in] position  - Ad's position (in channel's PTS)
	 * @param[in] offset    - Ad's start offset
	 * @param[in] duration  - Ad's duration in MS
	 * @param[in] errorCode - Error code, in case of placement error
	 */
	AdPlacementEvent(AAMPEventType evtType, const std::string &adId, uint32_t position, uint32_t offset=0, uint32_t duration=0, int errorCode=0);

	/**
	 * @brief AdPlacementEvent Destructor
	 */
	virtual ~AdPlacementEvent() { }

	/**
	 * @brief Get Ad's Identifier
	 *
	 * @return Ad's id
	 */
	const std::string &getAdId() const;

	/**
	 * @brief Get Ad's Position
	 *
	 * @return Ad's position (in channel's PTS)
	 */
	uint32_t getPosition() const;

	/**
	 * @brief Get Ad's Offset
	 *
	 * @return Ad's start offset
	 */
	uint32_t getOffset() const;

	/**
	 * @brief Get Ad's Duration
	 *
	 * @return Ad's duration in MS
	 */
	uint32_t getDuration() const;

	/**
	 * @brief Get Error Code
	 *
	 * @return Error code
	 */
	int getErrorCode() const;
};

/**
 * @brief Class for the Metrics Data event
 */
class MetricsDataEvent: public AAMPEventObject
{
	MetricsDataType mMetricsDataType;	/**< type of data , e.g AAMP_DATA_VIDEO_END for VideoEndEvent data */
	std::string mMetricUUID;		/**< unique session id passed during tune */
	std::string mMetricsData;		/**< metrics data */

public:
	MetricsDataEvent() = delete;
	MetricsDataEvent(const MetricsDataEvent&) = delete;
	MetricsDataEvent& operator=(const MetricsDataEvent&) = delete;

	/**
	 * @brief MetricsDataEvent Constructor
	 *
	 * @param[in]  dataType - Data type
	 * @param[in]  uuid     - unique identifier
	 * @param[in]  data     - Metrics data
	 */
	MetricsDataEvent(MetricsDataType dataType, const std::string &uuid, const std::string &data);

	/**
	 * @brief MetricsDataEvent Destructor
	 */
	virtual ~MetricsDataEvent() { }

	/**
	 * @brief Get Metrics Data Type
	 *
	 * @return Metrics data type
	 */
	MetricsDataType getMetricsDataType() const;

	/**
	 * @brief Get Metric UUID
	 *
	 * @return Uuid string
	 */
	const std::string &getMetricUUID() const;

	/**
	 * @brief Get Metrics Data
	 *
	 * @return Metrics data string
	 */
	const std::string &getMetricsData() const;
};

/**
 * @brief Class for the ID3 Metadata Event
 */
class ID3MetadataEvent: public AAMPEventObject
{
	std::vector<uint8_t> mMetadata;		/**< ID3 Metadata content */
	std::string mSchemeIdUri; // schemeIduri
	std::string mValue;
	uint32_t mTimeScale;
	uint64_t mPresentationTime;
	uint32_t mEventDuration;
	uint32_t mId;
	uint64_t mTimestampOffset;

public:
	ID3MetadataEvent() = delete;
	ID3MetadataEvent(const ID3MetadataEvent&) = delete;
	ID3MetadataEvent& operator=(const ID3MetadataEvent&) = delete;

	/*
	 * @brief ID3MetadataEvent Constructor
	 *
	 * @param[in] metadata - ID3 metadata
	 * @param[in] timeScale - timeScale od ID3 data
	 * @param[in] presentationTime - PTS value
	 * @param[in] eventDuration - eventDuration
	 * @param[in] id - id of ID3 data
	 * @param[in] timestampOffset
	 */
	ID3MetadataEvent(const std::vector<uint8_t> &metadata, const std::string &schIDUri, std::string &id3Value, uint32_t timeScale, uint64_t presentationTime, uint32_t eventDuration, uint32_t id, uint64_t timestampOffset);

	/**
	 * @brief ID3MetadataEvent Destructor
	 */
	virtual ~ID3MetadataEvent() { }

	/**
	 * @brief Get ID3 metdata
	 *
	 * @return ID3 metadata content
	 */
	const std::vector<uint8_t> &getMetadata() const;

	/**
	 * @brief Get ID3 metdata size
	 *
	 * @return ID3 metadata size
	 */
	int getMetadataSize() const;

	/**
	 * @brief Get schemeIdUri
	 *
	 * @return TimeScale value
	 */
	uint32_t getTimeScale() const;

	/**
	 * @brief Get eventDuration
	 *
	 * @return eventDuration value
	 */
	uint32_t getEventDuration() const;

	/**
	 * @brief Get id
	 *
	 * @return id value
	 */
	uint32_t getId() const;

	/**
         * @brief Get timestampOffset
         *
         * @return timestampOffset value
         */
        uint64_t getTimestampOffset() const;

	/**
	 * @brief Get presentationTime
	 *
	 * @return presentationTime value
	 */
	uint64_t getPresentationTime() const;

	/**
	 * @brief Get schemeIdUri
	 *
	 * @return schemeIdUri value
	 */
	const std::string& getSchemeIdUri() const;

	/**
	 * @brief Get value
	 *
	 * @return schemeIdUri value
	 */
	const std::string& getValue() const;
};

/**
 * @brief Class for the DRM Message Event
 */
class DrmMessageEvent: public AAMPEventObject
{
	std::string mMessage;		/**< DRM Message */

public:
	DrmMessageEvent() = delete;
	DrmMessageEvent(const DrmMessageEvent&) = delete;
	DrmMessageEvent& operator=(const DrmMessageEvent&) = delete;

	/*
	 * @brief DrmMessageEvent Constructor
	 *
	 * @param[in] msg - DRM message
	 */
	DrmMessageEvent(const std::string &msg);

	/**
	 * @brief DrmMessageEvent Destructor
	 */
	virtual ~DrmMessageEvent() { }

	/**
	 * @brief Get DRM Message
	 *
	 * @return DRM message
	 */
	const std::string &getMessage() const;
};

/**
 * @brief Class for the BlockedEvent   event
 */
class BlockedEvent: public AAMPEventObject
{
	std::string mReason;	/**< Blocked Reason  */

public:
	BlockedEvent() = delete;
	BlockedEvent(const BlockedEvent&) = delete;
	BlockedEvent& operator=(const BlockedEvent&) = delete;

	/*
	 * @brief BlockedEvent Constructor
	 * @param[in] reason     - Blocked Reason
	 */
	BlockedEvent(const std::string &reason) : AAMPEventObject(AAMP_EVENT_BLOCKED) , mReason(reason)
	{}

	/**
	 * @brief BlockedEvent Destructor
	 */
	virtual ~BlockedEvent() { }

	/**
	 * @brief Get Description
	 *
	 * @return Blocked Reason
	 */
	const std::string &getReason() const { return mReason; }
};

/**
 * @brief Class for the watermarkSession event
 */
class WatermarkSessionUpdateEvent: public AAMPEventObject
{
	uint32_t mSessionHandle; /**< Playback session handle used to track and manage sessions  */
	uint32_t mStatus; /**< Provides the status of the watermark session.  */
        std::string mSystem; /**< Describes content watermarking protection provider  */
public:
        WatermarkSessionUpdateEvent() = delete;
        WatermarkSessionUpdateEvent(const WatermarkSessionUpdateEvent&) = delete;
        WatermarkSessionUpdateEvent& operator=(const WatermarkSessionUpdateEvent&) = delete;

        /*
         * @brief WatermarkSessionUpdateEvent Constructor
         * @param[in]  sessionHandle - Handle used to track and manage session
         * @param[in]  status - Status of the watermark session
         * @param[in]  system - Watermarking protection provider
         */
        WatermarkSessionUpdateEvent(uint32_t sessionHandle, uint32_t status, const std::string &system) : AAMPEventObject(AAMP_EVENT_WATERMARK_SESSION_UPDATE) , mSessionHandle(sessionHandle), mStatus(status), mSystem(system)
        {}

        /**
         * @brief WatermarkSessionUpdateEvent Destructor
         */
        virtual ~WatermarkSessionUpdateEvent() { }

        /**
         * @brief Get session handle
         *
         * @return session handle
         */
        uint32_t getSessionHandle() const { return mSessionHandle; }

	/**
         * @brief Get session status 
         *
         * @return status
         */
        uint32_t getStatus() const { return mStatus; }

	/**
	 * @brief Get System
	 *
	 * @return System
	 */
	const std::string &getSystem() const { return mSystem; }
};

/**
 * @brief Class for the Content gap event
 */
class ContentGapEvent: public AAMPEventObject
{
	double mTime;			/**< Playback position in MS- relative to tune time - starts at zero */
	double mDuration;		/**< Duration of the timed event in MS */

public:
	ContentGapEvent() = delete;
	ContentGapEvent(const ContentGapEvent&) = delete;
	ContentGapEvent& operator=(const ContentGapEvent&) = delete;

	/*
	 * @brief ContentGapEvent Constructor
	 * @param[in] time      - Time of event
	 * @param[in] duration   - Duration of event
	 */
	ContentGapEvent(double time, double duration);

	/**
	 * @brief ContentGapEvent Destructor
	 */
	virtual ~ContentGapEvent() { }

	/**
	 * @brief Get Time
	 *
	 * @return Time of the ContentGap
	 */
	double getTime() const;

	/**
	 * @brief Get Duration
	 *
	 * @return Duration (in MS) of the ContentGap
	 */
	double getDuration() const;
};

using AAMPEventPtr = std::shared_ptr<AAMPEventObject>;
using MediaErrorEventPtr = std::shared_ptr<MediaErrorEvent>;
using SpeedChangedEventPtr = std::shared_ptr<SpeedChangedEvent>;
using ProgressEventPtr = std::shared_ptr<ProgressEvent>;
using CCHandleEventPtr = std::shared_ptr<CCHandleEvent>;
using MediaMetadataEventPtr = std::shared_ptr<MediaMetadataEvent>;
using BitrateChangeEventPtr = std::shared_ptr<BitrateChangeEvent>;
using TimedMetadataEventPtr = std::shared_ptr<TimedMetadataEvent>;
using BulkTimedMetadataEventPtr = std::shared_ptr<BulkTimedMetadataEvent>;
using StateChangedEventPtr = std::shared_ptr<StateChangedEvent>;
using SupportedSpeedsChangedEventPtr = std::shared_ptr<SupportedSpeedsChangedEvent>;
using SeekedEventPtr = std::shared_ptr<SeekedEvent>;
using TuneProfilingEventPtr = std::shared_ptr<TuneProfilingEvent>;
using BufferingChangedEventPtr = std::shared_ptr<BufferingChangedEvent>;
using DrmMetaDataEventPtr = std::shared_ptr<DrmMetaDataEvent>;
using AnomalyReportEventPtr = std::shared_ptr<AnomalyReportEvent>;
using WebVttCueEventPtr = std::shared_ptr<WebVttCueEvent>;
using AdResolvedEventPtr = std::shared_ptr<AdResolvedEvent>;
using AdReservationEventPtr = std::shared_ptr<AdReservationEvent>;
using AdPlacementEventPtr = std::shared_ptr<AdPlacementEvent>;
using MetricsDataEventPtr = std::shared_ptr<MetricsDataEvent>;
using ID3MetadataEventPtr = std::shared_ptr<ID3MetadataEvent>;
using DrmMessageEventPtr = std::shared_ptr<DrmMessageEvent>;
using BlockedEventPtr = std::shared_ptr<BlockedEvent>;
using WatermarkSessionUpdateEventPtr = std::shared_ptr<WatermarkSessionUpdateEvent>;
using ContentGapEventPtr = std::shared_ptr<ContentGapEvent>;

#endif /* __AAMP_EVENTS_H__ */

