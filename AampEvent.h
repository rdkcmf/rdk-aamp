/*
 * If not stated otherwise in this file or this component's license file the
 * following copyright and licenses apply:
 *
 * Copyright 2018 RDK Management
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
*/

/**
 * @file AampEvent.h
 * @brief Events supported by the AAMP player.
 */

#ifndef __AAMP_EVENTS_H__
#define __AAMP_EVENTS_H__

#include "vttCue.h" //Required for VTTCue
#include <memory>
#include <vector>

// Macros required for backward compatible AAMPEventListener implementation
#define MAX_LANGUAGE_COUNT 16
#define MAX_LANGUAGE_TAG_LENGTH 42 // <lang>-<role>
//(3+1+1) /* iso639-2 + optional 2..9 digit to disambiguate multiple same-language tracms, + nul terminator */

#define MAX_BITRATE_COUNT 10
#define MAX_SUPPORTED_SPEED_COUNT 12 /* [-64, -32, -16, -4, -1, 0, 0.5, 1, 4, 16, 32, 64] */

/**
 * @enum AAMPEventType 
 * @brief Type of the events sending to the JSPP player.
 */
typedef enum
{
	AAMP_EVENT_ALL_EVENTS = 0,	        /**< 0,	 All Events */
	AAMP_EVENT_TUNED = 1,			/**< 1,	 Tune success*/
	AAMP_EVENT_TUNE_FAILED,			/**< 2,	 Tune failure*/
	AAMP_EVENT_SPEED_CHANGED,		/**< 3,	 Speed changed internally*/
	AAMP_EVENT_EOS,				/**< 4,	 End of stream*/
	AAMP_EVENT_PLAYLIST_INDEXED,	        /**< 5,	 Playlist downloaded and indexed*/
	AAMP_EVENT_PROGRESS,			/**< 6,	 Progress event with playback stats. Report interval configurable */
	AAMP_EVENT_CC_HANDLE_RECEIVED,        	/**< 7,	 Sent when video decoder handle retrieved */
	AAMP_EVENT_JS_EVENT,			/**< 8,  Generic event generated by JavaScript binding */
	AAMP_EVENT_MEDIA_METADATA,		/**< 9,	 Meta-data of asset currently playing*/
	AAMP_EVENT_ENTERING_LIVE,		/**< 10, Event when live point reached*/
	AAMP_EVENT_BITRATE_CHANGED,		/**< 11, Event when bitrate changes */
	AAMP_EVENT_TIMED_METADATA,	        /**< 12, Meta-data of a subscribed tag parsed from manifest*/
	AAMP_EVENT_BULK_TIMED_METADATA,	        /**< 13, Bulk Meta-data of a subscribed tag parsed from manifest*/
	AAMP_EVENT_STATE_CHANGED,	        /**< 14, Event when player state changes */
	AAMP_EVENT_SPEEDS_CHANGED,		/**< 15, Event when supported playback speeds changes */
	AAMP_EVENT_SEEKED,			/**< 16, Event when seek completes, including new position*/
	AAMP_EVENT_TUNE_PROFILING,		/**< 17, Event when micro event data sends*/
	AAMP_EVENT_BUFFERING_CHANGED,	        /**< 18, Event when buffering starts/ends btw a playback*/
	AAMP_EVENT_DURATION_CHANGED,		/**< 19, Event when duration changed */
	AAMP_EVENT_AUDIO_TRACKS_CHANGED,	/**< 20, Event when available audio tracks changes */
	AAMP_EVENT_TEXT_TRACKS_CHANGED,		/**< 21, Event when available test tracks changes */
	AAMP_EVENT_AD_BREAKS_CHANGED,		/**< 22, Event when content/ad breaks changes */
	AAMP_EVENT_AD_STARTED,			/**< 23, Ad playback started */
	AAMP_EVENT_AD_COMPLETED,		/**< 24, Ad playback completed */
	AAMP_EVENT_DRM_METADATA,		/**< 25, Event with DRM metadata info*/
	AAMP_EVENT_REPORT_ANOMALY,		/**< 26, Playback Anomaly reporting */
	AAMP_EVENT_WEBVTT_CUE_DATA,		/**< 27, WebVTT Cue data */
	AAMP_EVENT_AD_RESOLVED,			/**< 28, Ad fulfill status */
	AAMP_EVENT_AD_RESERVATION_START,	/**< 29, Adbreak playback starts */
	AAMP_EVENT_AD_RESERVATION_END,		/**< 30, Adbreak playback ends */
	AAMP_EVENT_AD_PLACEMENT_START,		/**< 31, Ad playback starts */
	AAMP_EVENT_AD_PLACEMENT_END,		/**< 32, Ad playback ends */
	AAMP_EVENT_AD_PLACEMENT_ERROR,		/**< 33, Ad playback error */
	AAMP_EVENT_AD_PLACEMENT_PROGRESS,	/**< 34, Ad playback progress */
	AAMP_EVENT_REPORT_METRICS_DATA,		/**< 35, AAMP VideoEnd info reporting */
	AAMP_EVENT_ID3_METADATA,		/**< 36, ID3 metadata from audio stream */
	AAMP_EVENT_DRM_MESSAGE,         	/**< 37, Message from the DRM system */
	AAMP_EVENT_BLOCKED,         	        /**< 38, ATSC AV BLOCKED Event*/
	AAMP_EVENT_CONTENT_GAP,			/**< 39, Content gap event for progress gap reporting*/
	AAMP_EVENT_HTTP_RESPONSE_HEADER,        /**< 40, Http response header data */
	AAMP_EVENT_WATERMARK_SESSION_UPDATE,    /**< 41, Update on Watermark Session*/
	AAMP_EVENT_CONTENT_PROTECTION_DATA_UPDATE,	/**< 42, Update on Content Protection Data on Dynamic Key Rotation*/
	AAMP_MAX_NUM_EVENTS
} AAMPEventType;


/**
 * @enum AAMPEventMode
 * @brief AAMP event modes
 */
typedef enum
{
	AAMP_EVENT_DEFAULT_MODE = 0, /**< Aamp Default event mode */
	AAMP_EVENT_SYNC_MODE,        /**< Events handled in sync mode */
	AAMP_EVENT_ASYNC_MODE        /**< Events handled in Async mode */
}AAMPEventMode;

/**
 * @enum AAMPTuneFailure
 * @brief AAMP playback error codes
 */
typedef enum
{
	AAMP_TUNE_INIT_FAILED,				   /**< Tune failure due to initialization error*/
	AAMP_TUNE_INIT_FAILED_MANIFEST_DNLD_ERROR,         /**< Tune failure due to manifest download error*/
	AAMP_TUNE_INIT_FAILED_MANIFEST_CONTENT_ERROR,	   /**< Tune failure due to manifest content error*/
	AAMP_TUNE_INIT_FAILED_MANIFEST_PARSE_ERROR,	   /**< Tune failure due to manifest parse error*/
	AAMP_TUNE_INIT_FAILED_PLAYLIST_VIDEO_DNLD_ERROR,   /**< Tune failure due to video playlist download error*/
	AAMP_TUNE_INIT_FAILED_PLAYLIST_AUDIO_DNLD_ERROR,   /**< Tune failure due to audio playlist download error*/
	AAMP_TUNE_INIT_FAILED_TRACK_SYNC_ERROR,	           /**< Tune failure due to A/V track sync error*/
	AAMP_TUNE_MANIFEST_REQ_FAILED,			   /**< Tune failure caused by manifest fetch failure*/
	AAMP_TUNE_AUTHORISATION_FAILURE,		   /**< Not authorised to view the content*/
	AAMP_TUNE_FRAGMENT_DOWNLOAD_FAILURE,		   /**< When fragment download fails for 5 consecutive fragments*/
	AAMP_TUNE_INIT_FRAGMENT_DOWNLOAD_FAILURE,	   /**< Unable to download init fragment*/
	AAMP_TUNE_UNTRACKED_DRM_ERROR,			   /**< DRM error*/
	AAMP_TUNE_DRM_INIT_FAILED,			   /**< DRM initialization failure */
	AAMP_TUNE_DRM_DATA_BIND_FAILED,			   /**< InitData binding with DRM failed */
	AAMP_TUNE_DRM_SESSIONID_EMPTY,			   /**< DRM session ID empty */
	AAMP_TUNE_DRM_CHALLENGE_FAILED,			   /**< DRM key request challenge generation failed */
	AAMP_TUNE_LICENCE_TIMEOUT,			   /**< DRM license request timeout */
	AAMP_TUNE_LICENCE_REQUEST_FAILED,		   /**< DRM license got invalid response */
	AAMP_TUNE_INVALID_DRM_KEY,			   /**< DRM reporting invalid license key */
	AAMP_TUNE_UNSUPPORTED_STREAM_TYPE,		   /**< Unsupported stream type */
	AAMP_TUNE_UNSUPPORTED_AUDIO_TYPE,		   /**< Unsupported audio type in manifest */
	AAMP_TUNE_FAILED_TO_GET_KEYID,			   /**< Failed to parse key id from init data*/
	AAMP_TUNE_FAILED_TO_GET_ACCESS_TOKEN,		   /**< Failed to get session token from AuthService*/
	AAMP_TUNE_CORRUPT_DRM_DATA,			   /**< DRM failure due to corrupt drm data, self heal might clear further errors*/
	AAMP_TUNE_CORRUPT_DRM_METADATA,			   /**< DRM failure due to corrupt drm metadata in the stream*/
	AAMP_TUNE_DRM_DECRYPT_FAILED,			   /**< DRM Decryption Failed for Fragments */
	AAMP_TUNE_DRM_UNSUPPORTED,			   /**< DRM Format Unsupported */
	AAMP_TUNE_DRM_SELF_ABORT,			   /**< Download activity is aborted by player */
	AAMP_TUNE_GST_PIPELINE_ERROR,			   /**< Playback failure due to error from GStreamer pipeline or associated plugins */
	AAMP_TUNE_PLAYBACK_STALLED,			   /**< Playback was stalled due to valid fragments not available in playlist */
	AAMP_TUNE_CONTENT_NOT_FOUND,			   /**< The resource was not found at the URL provided (HTTP 404) */
	AAMP_TUNE_DRM_KEY_UPDATE_FAILED,		   /**< Failed to process DRM key, see the error code returned from Update() for more info */
	AAMP_TUNE_DEVICE_NOT_PROVISIONED,		   /**< STB not provisioned/corrupted; need to re-provision. */
	AAMP_TUNE_HDCP_COMPLIANCE_ERROR,		   /**< HDCP Compliance Check failure.Not compatible hdcp version for playback */
	AAMP_TUNE_INVALID_MANIFEST_FAILURE,		   /**< Manifest is invalid */
	AAMP_TUNE_FAILED_PTS_ERROR,			   /**< Playback failed due to PTS error */
	AAMP_TUNE_MP4_INIT_FRAGMENT_MISSING,		   /**< Init fragments missing in playlist */
	AAMP_TUNE_FAILURE_UNKNOWN			   /**<  Unknown failure */
} AAMPTuneFailure;

/**
 * @enum PrivAAMPState
 * @brief  Mapping all required status codes based on JS player requirement. These requirements may be
 * forced by psdk player.AAMP may not use all the statuses mentioned below:
 * Mainly required states - idle, initializing, initialized, preparing, prepared, playing, paused, seek, complete and error
 */
typedef enum
{
	eSTATE_IDLE,         /**< 0  - Player is idle */
	eSTATE_INITIALIZING, /**< 1  - Player is initializing a particular content */
	eSTATE_INITIALIZED,  /**< 2  - Player has initialized for a content successfully */
	eSTATE_PREPARING,    /**< 3  - Player is loading all associated resources */
	eSTATE_PREPARED,     /**< 4  - Player has loaded all associated resources successfully */
	eSTATE_BUFFERING,    /**< 5  - Player is in buffering state */
	eSTATE_PAUSED,       /**< 6  - Playback is paused */
	eSTATE_SEEKING,      /**< 7  - Seek is in progress */
	eSTATE_PLAYING,      /**< 8  - Playback is in progress */
	eSTATE_STOPPING,     /**< 9  - Player is stopping the playback */
	eSTATE_STOPPED,      /**< 10 - Player has stopped playback successfully */
	eSTATE_COMPLETE,     /**< 11 - Playback completed */
	eSTATE_ERROR,        /**< 12 - Error encountered and playback stopped */
	eSTATE_RELEASED,     /**< 13 - Player has released all resources for playback */
	eSTATE_BLOCKED       /**< 14 - Player has blocked and cant play content*/
} PrivAAMPState;

/**
 * @enum MetricsDataType
 * @brief AAMP metric data types
 */
typedef enum E_MetricsDataType
{
	AAMP_DATA_NONE,
	AAMP_DATA_VIDEO_END
} MetricsDataType;

/**
 * @enum VideoScanType Video Scan Type
 *
 * @brief VideoScanType - Progressive/Interlaced
 * */
typedef enum
{
	eVIDEOSCAN_PROGRESSIVE, /**< Progressive Video */
	eVIDEOSCAN_INTERLACED,  /**< Interlaced Video */
	eVIDEOSCAN_UNKNOWN      /**< Unknown Video */
}VideoScanType;

/**
 * @struct AAMPEvent
 * @brief Structure of the AAMP events.
 * Recommend new AAMP integration layers to use AAMPEventObject based listener
 * For new event definition, should use AAMPEventObject class
 * TODO: Deperecate in future, kept for backward compatibility only
 */
struct AAMPEvent
{
	AAMPEventType type; 		/**< Event type */

	union
	{
		struct
		{
			int severity;   /**< informative number indicates severity of msg, e.g Warning, Error, Trace etc */
			const char *msg;
		} anomalyReport;

		struct
		{
			const char *microData;   /**< micro event data for profiling */
		} tuneProfile;

		struct
		{
			MetricsDataType type; 		/**< type of data , e.g AAMP_DATA_VIDEO_END for VideoEndEvent data */
			const char *metricUUID;         /**< unique session id passed during tune */
			const char *data;               /**< data for event  */
		} metricsData;

		/**
		 * @brief Structure of the progress event data
		 */
		struct
		{
			double durationMiliseconds; 		/**< current size of time shift buffer */
			double positionMiliseconds; 		/**< current play/pause position relative to tune time - starts at zero) */
			float playbackSpeed;        		/**< current trick speed (1.0 for normal play rate) */
			double startMiliseconds;    		/**< time shift buffer start position (relative to tune time - starts at zero) */
			double endMiliseconds;      		/**< time shift buffer end position (relative to tune time - starts at zero) */
			long long videoPTS; 			/**< Video Presentation 90 Khz time-stamp  */
			double videoBufferedMiliseconds;	/**< current duration of buffered video ready to playback */
			const char* timecode;			/**< SEI Timecode information */
		} progress;

		/**
		 * @brief Structure of the seeked event data
		 */
		struct
		{
			double positionMiliseconds;	/**< new seeked position in milliseconds */
		} seeked;

		/**
		 * @brief Structure of the speed change event
		 */
		struct
		{
			float rate; /**< Playback rate */
		} speedChanged;

		/**
		 * @brief Structure of the bitrate change event
		 */
		struct
		{
			int time;                   /**< Playback time */
			long bitrate;               /**< Playback bitrate */
			const char *description;    /**< Description */
			int width;                  /**< Video width */
			int height;                 /**< Video height */
			double framerate;           /**< FrameRate */
			double position;            /**< bitrate changed position*/
			bool cappedProfile;         /**< profile capped status*/
			int displayWidth;	    /**< output display width*/
			int displayHeight;	    /**< output display height*/
			VideoScanType videoScanType;/**< video scan type*/
			int aspectRatioWidth;	    /**< aspect ratio width*/
			int aspectRatioHeight;	    /**< aspect ratio height*/
		} bitrateChanged;

		/**
		 * @brief Structure of the metadata event
		 */
		struct
		{
			long durationMiliseconds;                                       /**< Asset duration */
			int languageCount;                                              /**< Available language count */
			char languages[MAX_LANGUAGE_COUNT][MAX_LANGUAGE_TAG_LENGTH];    /**< Available languages */
			int bitrateCount;                                               /**< Available bitrate count */
			long bitrates[MAX_BITRATE_COUNT];                               /**< Available bitrates */
			int width;                                                      /**< Maximum video width */
			int height;                                                     /**< Maximum video height */
			bool hasDrm;                                                    /**< Drm enabled */
			int supportedSpeedCount;                                        /**< Supported playback speed count */
			float supportedSpeeds[MAX_SUPPORTED_SPEED_COUNT];                 /**< Supported playback speeds */
			double programStartTime;                                        /**< Program/Availability start time */
		} metadata;

		/**
		 * @brief Structure of the closed caption handle event
		 */
		struct
		{
			unsigned long handle;	/**< Closed caption handle */
		} ccHandle;

		/**
		 * @brief Structure of the timed metadata event
		 */
		struct
		{
			const char* szName;         /**< Metadata name */
			const char* id;             /**< Id of the timedMetadata */
			long long timeMilliseconds; /**< Playback position - relative to tune time - starts at zero */
			double durationMilliSeconds;/**< Duration of the timed event. */
			const char* szContent;      /**< Metadata content */
		} timedMetadata;

		/**
		 * @brief Structure of the bulk timed metadata event
		 */
		struct
		{
			const char* szMetaContent;      /**< Metadata content */
		} bulktimedMetadata;

		/**
		 * @brief Structure of the Java Script event
		 */
		struct
		{
			const char* szEventType;    /**< Event Type */
			void*  jsObject;            /**< Pointer to the Java Scipt Object */
		} jsEvent;

		/**
		 * @brief Structure of the media error event
		 */
		struct
		{
			AAMPTuneFailure failure;                            /**< Error Type */
			int code;                                           /**< Error code */
			const char *description;                            /**< Error description */
			bool shouldRetry;                                   /**< If recovery on retry is possible */
			int32_t classCode; /**< class Code */
			int32_t reasonCode; /**<reason Code */
			int32_t businessStatus; /**< business Status */
	
		} mediaError;

		struct
		{
			AAMPTuneFailure failure;                            /**< Error Type */
			const char *accessStatus;
			int accessStatus_value;
			int responseCode;
			bool isSecClientError;
		} dash_drmmetadata;

		/**
		 * @brief Structure of the player state changed event
		 */
		struct
		{
			PrivAAMPState state;        /**< Player state */
		} stateChanged;

		/**
		 * @brief Structure of the buffering changed event
		 */
		struct
		{
			bool buffering;            /**< true if buffering started, false otherwise */
		} bufferingChanged;

		/**
		 * @brief Structure of the supported speeds changed event
		 */
		struct
		{
			int supportedSpeedCount;                            /**< Supported playback speed count */
			float supportedSpeeds[MAX_SUPPORTED_SPEED_COUNT];     /**< Supported playback speeds */
		} speedsChanged;

		/**
		 * @brief Structure of the WebVTT cue data
		 */
		struct
		{
			VTTCue* cueData;
		} cue;

		/**
		 * @brief Structure for ad fulfill status event
		 */
		struct
		{
			bool resolveStatus;
			const char *adId;
			uint64_t startMS;
			uint64_t durationMs;
		} adResolved;

		/**
		 * @brief Structure for ad reservation events
		 */
		struct
		{
			const char *adBreakId;     /**< Reservation Id */
			uint64_t position;
		} adReservation;

		/**
		 * @brief Structure for ad placement events
		 */
		struct
		{
			const char *adId;		/**< Placement Id */
			uint32_t position;		/**<Ad Position relative to Reservation Start */
			uint32_t offset;		/**<Ad start offset */
			uint32_t duration;
			int errorCode;
		} adPlacement;

		/** @brief Structure of the id3 metadata event
		 */
		struct
		{
			uint8_t *data;   	 /**< Data pointer to ID3 metadata blob */
			int32_t length;		 /**< Length of the ID3 metadata blob */
		} id3Metadata;

		struct
		{
			const char *data;
		} drmMessage;

		struct
		{
			long long timeMilliseconds;	/**< Playback position - relative to tune time - starts at zero */
			double durationMilliSeconds;	/**< Duration of the gap */
		} contentGap;

		/**
		 * @brief Structure of the http response header event
		 */
		struct
		{
			const char* header;         /**< HTTP header name */
			const char* response;       /**< HTTP response value */
		} httpResponseHeader;

		/**
		 * @brief Structure of the content protection data update event
		*/
		struct
		{
			uint8_t *keyID;			/**< Session KeyID */
			const char* streamType;		/**< Session StreamType */
		} contentProtectionData;

	} data;

	/**
	 * @brief AAMPEvent Constructor
	 */
	AAMPEvent() : type(AAMP_MAX_NUM_EVENTS), data()
	{

	}

	/**
	 * @brief AAMPEvent Constructor
	 *
	 * @param[in] t Event type
	 */
	AAMPEvent(AAMPEventType t) : type(t), data()
	{

	}
	/**
         * @brief Copy constructor disabled
         *
         */
	AAMPEvent(const AAMPEvent&) = delete;
	/**
         * @brief assignment operator disabled
         *
         */
	AAMPEvent& operator=(const AAMPEvent&) = delete;
};

/**
 * @brief Base class of all AAMP events.
 * New AAMP event object for ease of use
 * While defining new event objects inherit from this base class
 */
class AAMPEventObject
{
	AAMPEventType mType;		/**< Event type */

public:

	AAMPEventObject() = delete;
	/**
         * @brief Copy constructor disabled
         *
         */
	AAMPEventObject(const AAMPEventObject&) = delete;
	/**
         * @brief assignment operator disabled
         *
         */
	AAMPEventObject& operator=(const AAMPEventObject&) = delete;

	/**
	 * @fn AAMPEventObject
	 */ 	 
	AAMPEventObject(AAMPEventType type);

	/**
	 * @brief AAMPEvent Destructor
	 */
	virtual ~AAMPEventObject() { }

	/**
	 * @fn getType
	 */
	AAMPEventType getType() const;
};

/**
 * @class MediaErrorEvent
 * @brief Class for the Media Error event
 */
class MediaErrorEvent: public AAMPEventObject
{
	AAMPTuneFailure mFailure;	/**< Error Type */
	int mCode;			/**< Error code */
	std::string mDescription;	/**< Error description */
	bool mShouldRetry;		/**< If recovery on retry is possible */
	
	int32_t mSecManagerClass;	/**< Secmanager error class */
	int32_t mSecManagerReasonCode; /**< Secmanager reason  code */
	int32_t mBusinessStatus;	/**< secclient business reason  code */

public:
	MediaErrorEvent() = delete;
	MediaErrorEvent(const MediaErrorEvent&) = delete;
	MediaErrorEvent& operator=(const MediaErrorEvent&) = delete;

	/**
	 * @fn MediaErrorEvent
	 *
	 * @param[in] failure     - Failure type
	 * @param[in] code        - Error code
	 * @param[in] desc        - Error description
	 * @param[in] shouldRetry - Retry or not
	 */
	MediaErrorEvent(AAMPTuneFailure failure, int code, const std::string &desc, bool shouldRetry, int32_t classCode, int32_t reason, int32_t businessStatus);

	/**
	 * @brief MediaErrorEvent Destructor
	 */
	virtual ~MediaErrorEvent() { }

	/**
	 * @fn getFailure
	 */
	AAMPTuneFailure getFailure() const;

	/**
	 * @fn getCode
	 */
	int getCode() const;

	/**
	 * @fn getDescription
	 */
	const std::string &getDescription() const;

	/**
	 * @fn shouldRetry
	 */ 	 
	bool shouldRetry() const;
	
	/**
	 * @fn getClass
	 */
	int32_t getClass() const;
	
	/**
	 * @fn getReason
	 */
	int32_t getReason() const;
	
	/**
	 * @fn getBusinessStatus
	 */
	int32_t getBusinessStatus() const;
};

/**
 * @class SpeedChangedEvent
 * @brief Class for the Speed changed event
 */
class SpeedChangedEvent: public AAMPEventObject
{
	float mRate;		/**< Playback rate */

public:
	SpeedChangedEvent() = delete;
	SpeedChangedEvent(const SpeedChangedEvent&) = delete;
	SpeedChangedEvent& operator=(const SpeedChangedEvent&) = delete;

	/**
	 * @fn SpeedChangedEvent
	 *
	 * @param[in]  rate - New speed
	 */
	SpeedChangedEvent(float rate);

	/**
	 * @brief SpeedChangedEvent Destructor
	 */
	virtual ~SpeedChangedEvent() { }

	/**
	 * @fn getRate
	 */
	float getRate() const;
};

/**
 * @class ProgressEvent
 * @brief Class for the Progress event
 */
class ProgressEvent: public AAMPEventObject
{
	double mDuration;		/**< current size of time shift buffer in MS*/
	double mPosition;		/**< current play/pause position relative to tune time - starts at zero) in MS */
	double mStart;			/**< time shift buffer start position (relative to tune time - starts at zero) in MS */
	double mEnd;			/**< time shift buffer end position (relative to tune time - starts at zero) in MS */
	float mSpeed;			/**< current trick speed (1.0 for normal play rate) */
	long long mPTS;			/**< Video Presentation 90 Khz time-stamp  */
	double mBufferedDuration;	/**< current duration of buffered video ready to playback */
	std::string mSEITimecode;   	/**< SEI Timecode information */

public:
	ProgressEvent() = delete;
	ProgressEvent(const ProgressEvent&) = delete;
	ProgressEvent& operator=(const ProgressEvent&) = delete;

	/**
	 * @fn ProgressEvent
	 *
	 * @param[in]  duration - Duration of Asset
	 * @param[in]  position - Current Position
	 * @param[in]  start    - Start Position
	 * @param[in]  end      - End Position
	 * @param[in]  speed    - Current Speed
	 * @param[in]  pts      - Video PTS
	 * @param[in]  bufferedDuration - buffered duration
	 */
	ProgressEvent(double duration, double position, double start, double end, float speed, long long pts, double bufferedDuration, std::string seiTimecode);

	/**
	 * @brief ProgressEvent Destructor
	 */
	virtual ~ProgressEvent() { }

	/**
	 * @fn getDuration
	 */
	double getDuration() const;

	/**
	 * @fn getPosition
	 *
	 */
	double getPosition() const;

	/**
	 * @fn getStart
	 *
	 */
	double getStart() const;

	/**
	 * @fn getEnd
	 */
	double getEnd() const;

	/**
	 * @fn getSpeed
	 */
	float getSpeed() const;

	/**
	 * @fn getPTS
	 *
	 */
	long long getPTS() const;

	/**
	 * @fn getBufferedDuration
	 */
	double getBufferedDuration() const;

	/**
	 * @fn getSEITimeCode
	 */
	const char* getSEITimeCode() const;
};

/**
 * @class CCHandleEvent
 * @brief Class for the Closed Caption Handle event
 */
class CCHandleEvent: public AAMPEventObject
{
	unsigned long mHandle;		/**< Closed caption handle */

public:
	CCHandleEvent() = delete;
	CCHandleEvent(const CCHandleEvent&) = delete;
	CCHandleEvent& operator=(const CCHandleEvent&) = delete;

	/**
	 * @fn CCHandleEvent
	 */
	CCHandleEvent(unsigned long handle);

	/**
	 * @brief CCHandleEvent Destructor
	 */
	virtual ~CCHandleEvent() { }

	/**
	 * @fn getCCHandle
	 */
	unsigned long getCCHandle() const;
};

/**
 * @class MediaMetadataEvent
 * @brief Class for the Media Metadata event
 */
class MediaMetadataEvent: public AAMPEventObject
{
	long mDuration;			    /**< Asset duration in MS */
	std::vector<std::string> mLanguages;/**< Available languages */
	std::vector<long> mBitrates;	    /**< Available bitrates */
	int mWidth;			    /**< Maximum video width */
	int mHeight;		    	    /**< Maximum video height */
	bool mHasDrm;			    /**< Drm enabled */
	std::vector<float> mSupportedSpeeds;  /**< Supported playback speeds */
	bool mIsLive;			    /**< Is Live */
	std::string mDrmType;		    /**< DRM type */
	double mProgramStartTime;	    /**< Program/Availability start time */

	/* Additional data from ATSC playback  */
	std::string mPCRating; 		/**< Parental control rating json string object  */
	int mSsi;  			/**<  Signal strength indicator 0-100 where 100 is a perfect signal. -1 indicates data not available  */
	/* Video info   */
	float mFrameRate;		/**< FrameRate */
	VideoScanType mVideoScanType;   /**< Video Scan Type progressive/interlaced */
	int mAspectRatioWidth;		/**< Aspect Ratio Width*/
	int mAspectRatioHeight;		/**< Aspect Ratio Height*/
	std::string mVideoCodec;	/**<  VideoCodec - E.g MPEG2.*/
	std::string mHdrType; 		/**< type of HDR being played, in example "DOLBY_VISION" */
	std::string mMediaFormatName;	/*< Media format type */

	/* Audio Info   */
	std::vector<long> mAudioBitrates; 	  /**< Available Audio bitrates */
	std::string mAudioCodec; 		  /**< AudioCodec E.g AC3.*/
	std::string mAudioMixType; 		  /**<  AudioMixType(- E.g STEREO. */
	bool  isAtmos;  	 		  /**<  Is Atmos : 1 - True if audio playing is Dolby Atmos, 0 false ,  -1 indicates data not available */

public:
	MediaMetadataEvent() = delete;
	MediaMetadataEvent(const MediaMetadataEvent&) = delete;
	MediaMetadataEvent& operator=(const MediaMetadataEvent&) = delete;

	/**
	 * @fn MediaMetadataEvent
	 *
	 * @param[in] duration - Duration of Media Metadata
	 * @param[in] width    - Video width
	 * @param[in] height   - Video height
	 * @param[in] hasDrm   - Drm enablement status
	 * @param[in] isLive   - Is Live
	 * @param[in] DrmType  - DRM Type
	 * @param[in] programStartTime  - Program/Availability start time
	 */
	MediaMetadataEvent(long duration, int width, int height, bool hasDrm, bool isLive, const std::string &DrmType, double programStartTime);

	/**
	 * @brief MediaMetadataEvent Destructor
	 */
	virtual ~MediaMetadataEvent() { }

	/**
	 * @fn getDuration
	 */ 	
	long getDuration() const;

	/**
	 * @fn getProgramStartTime
	 */
	double getProgramStartTime() const;

	/**
	 * @fn addLanguage
	 *
	 * @param[in] lang - Supported language
	 * @return void
	 */
	void addLanguage(const std::string &lang);

	/**
	 * @fn getLanguages
	 */
	const std::vector<std::string> &getLanguages() const;

	/**
	 * @fn getLanguagesCount
	 */
	int getLanguagesCount() const;

	/**
	 * @fn addBitrate
	 *
	 * @param[in] bitrate - Supported bitrate
	 * @return void
	 */
	void addBitrate(long bitrate);

	/**
	 * @fn getBitrates
	 */
	const std::vector<long> &getBitrates() const;

	/**
	 * @fn getBitratesCount
	 */
	int getBitratesCount() const;

	/**
	 * @fn getWidth
	 */
	int getWidth() const;

	/**
	 * @fn getHeight
	 */
	int getHeight() const;

	/**
	 * @fn hasDrmt
	 */
	bool hasDrm() const;

	/**
	 * @fn isLive
	 */
	bool isLive() const;

	/**
	 * @fn getDrmType
	 */
	const std::string &getDrmType() const;

	/**
	 * @fn addSupportedSpeed
	 *
	 * @param[in] speed - Supported speed
	 * @return void
	 */
	void addSupportedSpeed(float speed);

	/**
	 * @fn getSupportedSpeeds
	 */
	const std::vector<float> &getSupportedSpeeds() const;

	/**
	 * @fn getSupportedSpeedCount
	 */
	int getSupportedSpeedCount() const;

	/**
	 * @fn SetVideoMetaData
	 *
	 * @param[in] mFrameRate - video framerate
	 * @param[in] videoScanType   - Scan Type progressive/interlaced
	 * @param[in] aspectRatioWidth   - Aspect Ratio Width
	 * @param[in] aspectRatioHeight   - Aspect Ratio Height
	 * @param[in] strVideoCodec  - VideoCodec(v1) - E.g MPEG2.
	 * @param[in] strHdrType  - type of HDR being played, in example "DOLBY_VISION"
	 * @param[in] strPCRating  - Parental control rating json string object
	 * @param[int] ssi  - Signal strength indicator 0-100 where 100 is a perfect signal. -1 indicates data not available
	 */
	void SetVideoMetaData(float frameRate,VideoScanType videoScanType,int aspectRatioWidth,int  aspectRatioHeight, const std::string &videoCodec, const std::string  & hdrType, const std::string & pcRating, int ssi);

	/**
	 * @fn getAudioBitrates
	 */
	const std::vector<long> &getAudioBitrates() const { return mAudioBitrates; }

	/**
	 * @brief Sets additional metadata for Audio
	 *
	 * @param[in] strAudioCodec   - AudioCodec - E.g AC3.
	 * @param[in] strMixType   - AudioMixType - E.g STEREO.
	 * @param[in] iAtmos   - 1 - True if audio playing is Dolby Atmos, 0 false ,  -1 indicates data not available
	 */
	void SetAudioMetaData(const std::string &audioCodec,const std::string & mixType,bool  isAtmos );

	/**
	 * @brief Add a supported bitrate
	 *
	 * @param[in] bitrate - Supported bitrate
	 * @return void
	 */
	void addAudioBitrate(long bitrate) { return mAudioBitrates.push_back(bitrate); }

	/**
	 * @brief get Parental control ratings
	 *
	 * @return ratings string
	 */
	const std::string & getRatings() const { return mPCRating;}

	/**
	 * @brief get Signal strength indicator
	 *
	 * @return ratings string
	 */
	int getSsi() const { return mSsi;}

	/**
	 * @brief get framerate
	 *
	 * @return ratings string
	 */
	float getFrameRate() const {return mFrameRate;}

	/**
	 * @brief Get VideoScanType
	 *
	 * @return VideoScanType
	 */
	VideoScanType getVideoScanType() const { return mVideoScanType;}

	/**
	 * @brief Get AspectRatioWidth
	 *
	 * @return AspectRatioWidth
	 */
	int getAspectRatioWidth() const { return mAspectRatioWidth;}

	/**
	 * @brief Get AspectRatioHeight
	 *
	 * @return AspectRatioHeight
	 */
	int getAspectRatioHeight() const { return mAspectRatioHeight;}

	/**
	 * @brief Get VideoCodec
	 *
	 * @return VideoCodec
	 */
	const std::string & getVideoCodec() const { return mVideoCodec;}

	/**
	 * @brief Get HdrType
	 *
	 * @return HdrType
	 */
	const std::string & getHdrType() const { return mHdrType;}

	/**
	 * @brief Get AudioCodec
	 *
	 * @return AudioCodec
	 */
	const std::string & getAudioCodec() const {return mAudioCodec;}

	/**
	 * @brief returns AudioMixType
	 *
	 * @return AudioMixType
	 */
	const std::string & getAudioMixType() const {return mAudioMixType;}

	/**
	 * @brief Get Atmos info
	 *
	 * @return true/false
	 */
	bool getAtmosInfo() const {return  isAtmos;}
		/**
	 * @brief Get Media format type
	 *
	 * @return mediaFormat
	 */
	const std::string & getMediaFormat() { return mMediaFormatName; }

	/**
	 * @brief Set Media format type
	 *
	 * @return void
	 */
	void setMediaFormat(const std::string &mediaFormatName) { mMediaFormatName = mediaFormatName; }
};

/**
 * @class BitrateChangeEvent
 * @brief Class for the Bitrate change event
 */
class BitrateChangeEvent: public AAMPEventObject
{
	int mTime;			/**< Playback time */
	long mBitrate;			/**< Playback bitrate */
	std::string mDescription;	/**< Bitrate change reason */
	int mWidth;			/**< Video width */
	int mHeight;			/**< Video height */
	double mFrameRate;		/**< FrameRate */
	double mPosition;		/**< Position at which bitrate changed */
	bool mCappedProfile;  	        /**< Capped/Restricted profile status */
	int mDisplayWidth;		/**< TV display width */
	int mDisplayHeight;		/**< TV display height */
	VideoScanType mVideoScanType;   /**< Video Scan Type progressive/interlaced */
	int mAspectRatioWidth;		/**< Aspect Ratio Width*/
	int mAspectRatioHeight;		/**< Aspect Ratio Height*/

public:
	BitrateChangeEvent() = delete;
	BitrateChangeEvent(const BitrateChangeEvent&) = delete;
	BitrateChangeEvent& operator=(const BitrateChangeEvent&) = delete;

	/**
	 * @fn BitrateChangeEvent
	 *
	 * @param[in] time       - Time of bitrate change
	 * @param[in] bitrate    - New bitrate
	 * @param[in] desc       - Reason of change
	 * @param[in] width      - Video width
	 * @param[in] height     - Video height
	 * @param[in] frameRate  - Framerate
	 * @param[in] position   - Position
	 * @param[in] cappedProfile - Profile capping status
	 * @param[in] displayWidth - Output tv display width
	 * @param[in] displayHeight - Output tv dispay height
	 * @param[in] videoScanType   - Video Scan Type
	 * @param[in] position   - Aspect Ratio Width
	 * @param[in] position   - Aspect Ratio Height
	 */
	BitrateChangeEvent(int time, long bitrate, const std::string &desc, int width, int height, double frameRate, double position, bool mCappedProfile, int mDisplayWidth, int mDisplayHeight, VideoScanType videoScanType, int aspectRatioWidth, int aspectRatioHeight);

	/**
	 * @brief BitrateChangeEvent Destructor
	 */
	virtual ~BitrateChangeEvent() { }

	/**
	 * @fn getTime
	 */
	int getTime() const;

	/**
	 * @fn getBitrate
	 */
	long getBitrate() const;

	/**
	 * @fn getDescription
	 */
	const std::string &getDescription() const;

	/**
	 * @fn getWidth
	 */ 	 
	int getWidth() const;

	/**
	 * @fn getHeight
	 */
	int getHeight() const;

	/**
	 * @fn getFrameRate
	 */
	double getFrameRate() const;

	/**
	 * @fn getPosition
	 */
	double getPosition() const;

	/**
         * @fn getCappedProfileStatus
         */
        bool getCappedProfileStatus() const;

	/**
         * @fn getDisplayWidth
         */
        int getDisplayWidth() const;

	 /**
          * @fn getDisplayHeight
          */
        int getDisplayHeight() const;

	/**
	 * @fn getScanType
	 */
	VideoScanType getScanType() const;
	/**
	 * @fn getAspectRatioWidth
	 */
	int getAspectRatioWidth() const;
	/**
	 * @fn getAspectRatioHeight
	 */
	int getAspectRatioHeight() const;
};

/**
 * @class TimedMetadataEvent
 * @brief Class for the Timed Metadata event
 */
class TimedMetadataEvent: public AAMPEventObject
{
	std::string mName;		/**< Metadata name */
	std::string mId;		/**< Id of the timedMetadata */
	double mTime;			/**< Playback position in MS- relative to tune time - starts at zero */
	double mDuration;		/**< Duration of the timed event in MS */
	std::string mContent;		/**< Metadata content */

public:
	TimedMetadataEvent() = delete;
	TimedMetadataEvent(const TimedMetadataEvent&) = delete;
	TimedMetadataEvent& operator=(const TimedMetadataEvent&) = delete;

	/**
	 * @fn TimedMetadataEvent
	 *
	 * @param[in] name      - TimedMetadata name
	 * @param[in] id        - TimedMetadata id
	 * @param[in] time      - Time of event
	 * @param[in] duration   - Duration of event
	 * @param[in] content   - Content field of the TimedMetadata
	 */
	TimedMetadataEvent(const std::string &name, const std::string &id, double time, double duration, const std::string &content);

	/**
	 * @brief TimedMetadataEvent Destructor
	 */
	virtual ~TimedMetadataEvent() { }

	/**
	 * @fn getName
	 */
	const std::string &getName() const;

	/**
	 * @fn getId
	 */
	const std::string &getId() const;

	/**
	 * @fn getTime
	 */
	double getTime() const;

	/**
	 * @fn getDuration
	 */
	double getDuration() const;

	/**
	 * @fn getContent
	 */
	const std::string &getContent() const;
};

/**
 * @class BulkTimedMetadataEvent
 * @brief Class for the Bulk TimedMetadata Event
 */
class BulkTimedMetadataEvent: public AAMPEventObject
{
	std::string mContent;		/**< Metadata content */

public:
	BulkTimedMetadataEvent() = delete;
	BulkTimedMetadataEvent(const BulkTimedMetadataEvent&) = delete;
	BulkTimedMetadataEvent& operator=(const BulkTimedMetadataEvent&) = delete;

	/**
	 * @fn BulkTimedMetadataEvent
	 *
	 * @param[in] content - metadata serialized in JSON format
	 */
	BulkTimedMetadataEvent(const std::string &content);

	/**
	 * @brief BulkTimedMetadataEvent Destructor
	 */
	virtual ~BulkTimedMetadataEvent() { }

	/**
	 * @fn getContent
	 */
	const std::string &getContent() const;
};

/**
 * @class StateChangedEvent
 * @brief Class for the Player State Changed event
 */
class StateChangedEvent: public AAMPEventObject
{
	PrivAAMPState mState;	/**< Player state */

public:
	StateChangedEvent() = delete;
	StateChangedEvent(const StateChangedEvent&) = delete;
	StateChangedEvent& operator=(const StateChangedEvent&) = delete;

	/**
	 * @fn StateChangedEvent
	 *
	 * @param[in] state - New player state
	 */
	StateChangedEvent(PrivAAMPState state);

	/**
	 * @brief StateChangedEvent Destructor
	 */
	virtual ~StateChangedEvent() { }

	/**
	 * @brief Get Current Player State
	 *
	 * @return Player state
	 */
	PrivAAMPState getState() const;
};

/**
 * @class SupportedSpeedsChangedEvent
 * @brief Class for the supported speeds changed event
 */
class SupportedSpeedsChangedEvent: public AAMPEventObject
{
	std::vector<float> mSupportedSpeeds;     /**< Supported playback speeds */

public:
	/**
         * @brief Copy constructor disabled
         *
         */
	SupportedSpeedsChangedEvent(const SupportedSpeedsChangedEvent&) = delete;
	/**
	 * @brief assignment operator disabled
	 *
 	 */
	SupportedSpeedsChangedEvent& operator=(const SupportedSpeedsChangedEvent&) = delete;

	/**
	 * @fn SupportedSpeedsChangedEvent
	 */
	SupportedSpeedsChangedEvent();

	/**
	 * @brief SupportedSpeedsChangedEvent Destructor
	 */
	virtual ~SupportedSpeedsChangedEvent() { }

	/**
	 * @fn addSupportedSpeed
	 *
	 * @param[in] speed - Speed
	 * @return void
	 */
	void addSupportedSpeed(float speed);

	/**
	 * @fn getSupportedSpeeds
	 */
	const std::vector<float> &getSupportedSpeeds() const;

	/**
	 * @fn getSupportedSpeedCount
	 */
	int getSupportedSpeedCount() const;
};

/**
 * @class SeekedEvent
 * @brief Class for the Seeked Event
 */
class SeekedEvent: public AAMPEventObject
{
	double mPosition;		/**< new seeked position in milliseconds */

public:
	SeekedEvent() = delete;
	SeekedEvent(const SeekedEvent&) = delete;
	SeekedEvent& operator=(const SeekedEvent&) = delete;

	/**
	 * @fn SeekedEvent
	 */
	SeekedEvent(double positionMS);

	/**
	 * @brief SeekedEvent Destructor
	 */
	virtual ~SeekedEvent() { }

	/**
	 * @fn getPosition
	 */
	double getPosition() const;
};

/**
 * @class TuneProfilingEvent
 * @brief Class for the Tune Profilng Event
 */
class TuneProfilingEvent: public AAMPEventObject
{
	std::string mProfilingData;	/**< micro event data for profiling */

public:
	TuneProfilingEvent() = delete;
	TuneProfilingEvent(const TuneProfilingEvent&) = delete;
	TuneProfilingEvent& operator=(const TuneProfilingEvent&) = delete;

	/**
	 * @fn TuneProfilingEvent
	 *
	 * @param[in] profilingData - tune profiling data
	 */
	TuneProfilingEvent(std::string &profilingData);

	/**
	 * @brief TuneProfilingEvent Destructor
	 */
	virtual ~TuneProfilingEvent() { }

	/**
	 * @fn getProfilingData
	 */
	const std::string &getProfilingData() const;
};

/**
 * @class BufferingChangedEvent
 * @brief Class for the Buffering Changed event
 */
class BufferingChangedEvent: public AAMPEventObject
{
	bool mBuffering;	/**< true : Availability of buffer to play, false : Underflow / non-availability of buffer to play */

public:
	BufferingChangedEvent() = delete;
	BufferingChangedEvent(const BufferingChangedEvent&) = delete;
	BufferingChangedEvent& operator=(const BufferingChangedEvent&) = delete;

	/**
	 * @fn BufferingChangedEvent
	 *
	 * @param[in] buffering - Buffering status
	 */
	BufferingChangedEvent(bool buffering);

	/**
	 * @brief BufferingChangedEvent Destructor
	 */
	virtual ~BufferingChangedEvent() { }

	/**
	 * @fn buffering
	 */
	bool buffering() const;
};

/**
 * @brief Class for the Drm Metadata event
 */
class DrmMetaDataEvent: public AAMPEventObject
{
	AAMPTuneFailure mFailure;	/**< Error Type */
	std::string mAccessStatus;	/**< Access status */
	int mAccessStatusValue;		/**< Access status value */
	int mResponseCode;		/**< Response code */
	bool mSecclientError;		/**< Is secclient error */
	
	int32_t mSecManagerClass;	/**< Secmanager error class */
	int32_t mSecManagerReasonCode; /**< Secmanager reason  code */
	int32_t mBusinessStatus;	/**< secclient business reason  code */
public:
	DrmMetaDataEvent() = delete;
	DrmMetaDataEvent(const DrmMetaDataEvent&) = delete;
	DrmMetaDataEvent& operator=(const DrmMetaDataEvent&) = delete;

	/*
	 * @brief DrmMetaDataEvent Constructor
	 *
	 * @param[in] failure      - Failure type
	 * @param[in] accessStatus - Access status
	 * @param[in] statusValue  - Access status value
	 * @param[in] responseCode - Response code
	 * @param[in] secclientErr - Is secclient error
	 */
	DrmMetaDataEvent(AAMPTuneFailure failure, const std::string &accessStatus, int statusValue, int responseCode, bool secclientErr);

	/**
	 * @brief DrmMetaDataEvent Destructor
	 */
	virtual ~DrmMetaDataEvent() { }

	/**
	 * @brief Get Failure type
	 *
	 * @return Tune failure type
	 */
	AAMPTuneFailure getFailure() const;

	/**
	 * @brief Set Failure type
	 *
	 * @param[in] failure - Failure type
	 * @return void
	 */
	void setFailure(AAMPTuneFailure failure);

	/**
	 * @brief Get Access Status
	 *
	 * @return Access status string
	 */
	const std::string &getAccessStatus() const;

	/**
	 * @brief Set Access Status
	 *
	 * @param[in] status - Access status
	 * @return void
	 */
	void setAccessStatus(const std::string &status);

	/**
	 * @brief Get Access Status
	 *
	 * @return Access status value
	 */
	int getAccessStatusValue() const;

	/**
	 * @brief Set Access Status Value
	 *
	 * @param[in] value - Access status value
	 * @return void
	 */
	void setAccessStatusValue(int value);

	/**
	 * @brief Get Response Code
	 *
	 * @return Response code
	 */
	int getResponseCode() const;
	
	/**
	 * @brief Get Response Code
	 *
	 * @return Response code
	 */
	int32_t getSecManagerReasonCode() const;
	
	/**
	 * @brief Get Response Code
	 *
	 * @return Response code
	 */
	int32_t getSecManagerClassCode() const;
	
	/**
	 * @brief Get Response Code
	 *
	 * @return Response code
	 */
	int32_t getBusinessStatus() const;
	
	/**
	 * @brief Set Response Code
	 *
	 * @param[in] code - Response code
	 * @return void
	 */
	void setResponseCode(int code);
	
	/**
	 * @brief Get Secmanager response code
	 * @param[string] code - secmanager reason code
	 * @return Response code
	 */
	void setSecManagerReasonCode(int32_t code);

	/**
	 * @brief Get secclient error status
	 *
	 * @return secclient error (true/false)
	 */
	bool getSecclientError() const;
	   
	/**
	 * @brief Set secclient error status
	 *
	 * @param[in] sec client error status (true/false)
	 * @return void
	 */
	void setSecclientError(bool secclientError);
	
	/**
	 * @brief Set the secmanager DRM error responses
	 */
	void SetVerboseErrorCode(int32_t statusCode,  int32_t reasonCode, int32_t businessStatus );

	/**
	 * @brief Convert the secclient DRM error code into secmanager error code to have a unified verbose error reported
	 */
	void ConvertToVerboseErrorCode(int32_t httpCode, int32_t httpExtStatusCode );
};


/**
 * @class AnomalyReportEvent
 * @brief Class for the Anomaly Report Event.
 */
class AnomalyReportEvent: public AAMPEventObject
{
	int mSeverity;			/**< informative number indicates severity of msg, e.g Warning, Error, Trace etc */
	std::string mMsg;		/**< Anomaly message */

public:
	AnomalyReportEvent() = delete;
	AnomalyReportEvent(const AnomalyReportEvent&) = delete;
	AnomalyReportEvent& operator=(const AnomalyReportEvent&) = delete;

	/**
	 * @fn AnomalyReportEvent
	 *
	 * @param[in]  severity - Severity of message
	 * @param[in]  msg      - Anomaly message
	 */
	AnomalyReportEvent(int severity, const std::string &msg);

	/**
	 * @brief AnomalyReportEvent Destructor
	 */
	virtual ~AnomalyReportEvent() { }

	/**
	 * @fn getSeverity
	 */
	int getSeverity() const;

	/**
	 * @fn getMessage
	 */
	const std::string &getMessage() const;
};

/**
 * @class WebVttCueEvent
 * @brief Class for the Web VTT Cue Event
 */
class WebVttCueEvent: public AAMPEventObject
{
	VTTCue* mCueData;	/**< Web VTT cue data */

public:
	WebVttCueEvent() = delete;
	WebVttCueEvent(const WebVttCueEvent&) = delete;
	WebVttCueEvent& operator=(const WebVttCueEvent&) = delete;

	/**
	 * @fn WebVttCueEvent
	 *
	 * @param[in] cueData - Pointer to VTT cue data
	 */
	WebVttCueEvent(VTTCue* cueData);

	/**
	 * @brief WebVttCueEvent Destructor
	 */
	virtual ~WebVttCueEvent() { }

	/**
	 * @fn getCueData
	 */
	VTTCue* getCueData() const;
};

/**
 * @class AdResolvedEvent
 * @brief Class for ad fulfill status event
 */
class AdResolvedEvent: public AAMPEventObject
{
	bool mResolveStatus;	/**<Ad resolve status */
	std::string mAdId;	/**<Ad identifier */
	uint64_t mStartMS;	/**<Ad's start position in MS */
	uint64_t mDurationMs;	/**<Ad's duration in MS */

public:
	AdResolvedEvent() = delete;
	AdResolvedEvent(const AdResolvedEvent&) = delete;
	AdResolvedEvent& operator=(const AdResolvedEvent&) = delete;

	/**
	 * @fn AdResolvedEvent
	 *
	 * @param[in] resolveStatus - Ad resolve status
	 * @param[in] adId          - Identifier of the Ad
	 * @param[in] startMS       - Start position of Ad (relative to reservation start)
	 * @param[in] durationMs    - Duration of the Ad in MS
	 */
	AdResolvedEvent(bool resolveStatus, const std::string &adId, uint64_t startMS, uint64_t durationMs);

	/**
	 * @brief AdResolvedEvent Destructor
	 */
	virtual ~AdResolvedEvent() { }

	/**
	 * @fn getResolveStatus
	 */
	bool getResolveStatus() const;

	/**
	 * @fn getAdId
	 */
	const std::string &getAdId() const;

	/**
	 * @fn getStart
	 */
	uint64_t getStart() const;

	/**
	 * @fn getDuration
	 */
	uint64_t getDuration() const;

};

/**
 * @class AdReservationEvent
 * @brief Class for ad reservation events
 */
class AdReservationEvent: public AAMPEventObject
{
	std::string mAdBreakId;	/**<Adbreak's id */
	uint64_t mPosition;	/**<Adbreak's start position */

public:
	AdReservationEvent() = delete;
	AdReservationEvent(const AdReservationEvent&) = delete;
	AdReservationEvent& operator=(const AdReservationEvent&) = delete;

	/**
	 * @fn AdReservationEvent
	 *
	 * @param[in] evtType  - Event Type
	 * @param[in] breakId  - Unique identifier of Ad reservation.
	 * @param[in] position - Postion of reservation in content's PTS
	 */
	AdReservationEvent(AAMPEventType evtType, const std::string &breakId, uint64_t position);

	/**
	 * @brief AdReservationEvent Destructor
	 */
	virtual ~AdReservationEvent() { }

	/**
	 * @fn getAdBreakId
	 */
	const std::string &getAdBreakId() const;

	/**
	 * @fn getPosition
	 */
	uint64_t getPosition() const;
};

/**
 * @class AdPlacementEvent
 * @brief Class for ad placement events
 */
class AdPlacementEvent: public AAMPEventObject
{
	std::string mAdId;	/**< Ad Id */
	uint32_t mPosition;	/**< Ad Position relative to Reservation Start */
	uint32_t mOffset;	/**< Ad start offset */
	uint32_t mDuration;	/**< Ad's duration */
	int mErrorCode;		/**< Error code, if any */

public:
	AdPlacementEvent() = delete;
	AdPlacementEvent(const AdPlacementEvent&) = delete;
	AdPlacementEvent& operator=(const AdPlacementEvent&) = delete;

	/**
	 * @fn AdPlacementEvent
	 *
	 * @param[in] evtType   - Event type
	 * @param[in] adId      - Ad Id
	 * @param[in] position  - Ad's position (in channel's PTS)
	 * @param[in] offset    - Ad's start offset
	 * @param[in] duration  - Ad's duration in MS
	 * @param[in] errorCode - Error code, in case of placement error
	 */
	AdPlacementEvent(AAMPEventType evtType, const std::string &adId, uint32_t position, uint32_t offset=0, uint32_t duration=0, int errorCode=0);

	/**
	 * @brief AdPlacementEvent Destructor
	 */
	virtual ~AdPlacementEvent() { }

	/**
	 * @fn getAdId
	 */
	const std::string &getAdId() const;

	/**
	 * @fn getPosition
	 */
	uint32_t getPosition() const;

	/**
	 * @fn getOffset
	 */
	uint32_t getOffset() const;

	/**
	 * @fn getDuration
	 */
	uint32_t getDuration() const;

	/**
	 * @fn getErrorCode
	 */
	int getErrorCode() const;
};

/**
 * @class MetricsDataEvent 
 * @brief Class for the Metrics Data event
 */
class MetricsDataEvent: public AAMPEventObject
{
	MetricsDataType mMetricsDataType;	/**< type of data , e.g AAMP_DATA_VIDEO_END for VideoEndEvent data */
	std::string mMetricUUID;		/**< unique session id passed during tune */
	std::string mMetricsData;		/**< metrics data */

public:
	MetricsDataEvent() = delete;
	MetricsDataEvent(const MetricsDataEvent&) = delete;
	MetricsDataEvent& operator=(const MetricsDataEvent&) = delete;

	/**
	 * @fn MetricsDataEvent
	 *
	 * @param[in]  dataType - Data type
	 * @param[in]  uuid     - unique identifier
	 * @param[in]  data     - Metrics data
	 */
	MetricsDataEvent(MetricsDataType dataType, const std::string &uuid, const std::string &data);

	/**
	 * @brief MetricsDataEvent Destructor
	 */
	virtual ~MetricsDataEvent() { }

	/**
	 * @fn getMetricsDataType
	 *
	 */
	MetricsDataType getMetricsDataType() const;

	/**
	 * @fn getMetricUUID
	 */
	const std::string &getMetricUUID() const;

	/**
	 * @fn getMetricsData
	 */
	const std::string &getMetricsData() const;
};

/**
 * @class ID3MetadataEvent
 * @brief Class for the ID3 Metadata Event
 */
class ID3MetadataEvent: public AAMPEventObject
{
	std::vector<uint8_t> mMetadata;		/**< ID3 Metadata content */
	std::string mSchemeIdUri; // schemeIduri
	std::string mValue;
	uint32_t mTimeScale;
	uint64_t mPresentationTime;
	uint32_t mEventDuration;
	uint32_t mId;
	uint64_t mTimestampOffset;

public:
	ID3MetadataEvent() = delete;
	ID3MetadataEvent(const ID3MetadataEvent&) = delete;
	ID3MetadataEvent& operator=(const ID3MetadataEvent&) = delete;

	/**
	 * @brief ID3MetadataEvent
	 *
	 * @param[in] metadata - ID3 metadata
	 * @param[in] timeScale - timeScale od ID3 data
	 * @param[in] presentationTime - PTS value
	 * @param[in] eventDuration - eventDuration
	 * @param[in] id - id of ID3 data
	 * @param[in] timestampOffset
	 */
	ID3MetadataEvent(const std::vector<uint8_t> &metadata, const std::string &schIDUri, std::string &id3Value, uint32_t timeScale, uint64_t presentationTime, uint32_t eventDuration, uint32_t id, uint64_t timestampOffset);

	/**
	 * @brief ID3MetadataEvent Destructor
	 */
	virtual ~ID3MetadataEvent() { }

	/**
	 * @fn getMetadata
	 */
	const std::vector<uint8_t> &getMetadata() const;

	/**
	 * @fn getMetadataSize
	 */
	int getMetadataSize() const;

	/**
	 * @fn getTimeScale
	 */
	uint32_t getTimeScale() const;

	/**
	 * @fn getEventDuration
	 */
	uint32_t getEventDuration() const;

	/**
	 * @fn getId
	 */
	uint32_t getId() const;

	/**
         * @fn getTimestampOffset
         */
        uint64_t getTimestampOffset() const;

	/**
	 * @fn getPresentationTime
	 */
	uint64_t getPresentationTime() const;

	/**
	 * @fn getSchemeIdUri
	 */
	const std::string& getSchemeIdUri() const;

	/**
	 * @fn getValue
	 */
	const std::string& getValue() const;
};

/**
 * @class DrmMessageEvent
 * @brief Class for the DRM Message Event
 */
class DrmMessageEvent: public AAMPEventObject
{
	std::string mMessage;		/**< DRM Message */

public:
	DrmMessageEvent() = delete;
	DrmMessageEvent(const DrmMessageEvent&) = delete;
	DrmMessageEvent& operator=(const DrmMessageEvent&) = delete;

	/**
	 * @fn DrmMessageEvent
	 *
	 * @param[in] msg - DRM message
	 */
	DrmMessageEvent(const std::string &msg);

	/**
	 * @brief DrmMessageEvent Destructor
	 */
	virtual ~DrmMessageEvent() { }

	/**
	 * @fn getMessage
	 */
	const std::string &getMessage() const;
};

/**
 * @class BlockedEvent
 * @brief Class for the BlockedEvent   event
 */
class BlockedEvent: public AAMPEventObject
{
	std::string mReason;	/**< Blocked Reason  */

public:
	BlockedEvent() = delete;
	BlockedEvent(const BlockedEvent&) = delete;
	BlockedEvent& operator=(const BlockedEvent&) = delete;

	/**
	 * @brief BlockedEvent Constructor
	 * @param[in] reason     - Blocked Reason
	 */
	BlockedEvent(const std::string &reason) : AAMPEventObject(AAMP_EVENT_BLOCKED) , mReason(reason)
	{}

	/**
	 * @brief BlockedEvent Destructor
	 */
	virtual ~BlockedEvent() { }

	/**
	 * @brief Get Description
	 *
	 * @return Blocked Reason
	 */
	const std::string &getReason() const { return mReason; }
};

/**
 * @class ContentGapEvent
 * @brief Class for the Content gap event
 */
class ContentGapEvent: public AAMPEventObject
{
	double mTime;			/**< Playback position in MS- relative to tune time - starts at zero */
	double mDuration;		/**< Duration of the timed event in MS */

public:
	ContentGapEvent() = delete;
	ContentGapEvent(const ContentGapEvent&) = delete;
	ContentGapEvent& operator=(const ContentGapEvent&) = delete;

	/**
	 * @fn ContentGapEvent
	 * @param[in] time      - Time of event
	 * @param[in] duration   - Duration of event
	 */
	ContentGapEvent(double time, double duration);

	/**
	 * @brief ContentGapEvent Destructor
	 */
	virtual ~ContentGapEvent() { }

	/**
	 * @fn getTime
	 */
	double getTime() const;

	/**
	 * @fn getDuration
	 */
	double getDuration() const;
};

/**
 * @class HTTPResponseHeaderEvent
 * @brief Class for the HTTP Response Header event 
 */
class HTTPResponseHeaderEvent: public AAMPEventObject
{
	std::string mHeaderName;	/**< Header name */
	std::string mHeaderResponse;	/**< Header response */

public:
	HTTPResponseHeaderEvent() = delete;
	HTTPResponseHeaderEvent(const HTTPResponseHeaderEvent&) = delete;
	HTTPResponseHeaderEvent& operator=(const HTTPResponseHeaderEvent&) = delete;

	/**
	 * @fn HTTPResponseHeaderEvent
	 *
	 * @param[in] name         - HTTPResponseHeader name
	 * @param[in] response     - HTTPResponseHeader response
	 */
	HTTPResponseHeaderEvent(const std::string &name, const std::string &response);

	/**
	 * @brief HTTPResponseHeaderEvent Destructor
	 */
	virtual ~HTTPResponseHeaderEvent() { }

	/**
	 * @fn getHeader
	 */
	const std::string &getHeader() const;

	/**
	 * @fn getResponse
	 */
	const std::string &getResponse() const;

};

/**
 * @class WatermarkSessionUpdateEvent
 * @brief Class for the watermarkSession event
 */
class WatermarkSessionUpdateEvent: public AAMPEventObject
{
	uint32_t mSessionHandle; /**< Playback session handle used to track and manage sessions  */
	uint32_t mStatus; 	 /**< Provides the status of the watermark session.  */
        std::string mSystem; 	 /**< Describes content watermarking protection provider  */
public:
        WatermarkSessionUpdateEvent() = delete;
        WatermarkSessionUpdateEvent(const WatermarkSessionUpdateEvent&) = delete;
        WatermarkSessionUpdateEvent& operator=(const WatermarkSessionUpdateEvent&) = delete;

        /**
         * @brief WatermarkSessionUpdateEvent Constructor
         * @param[in]  sessionHandle - Handle used to track and manage session
         * @param[in]  status - Status of the watermark session
         * @param[in]  system - Watermarking protection provider
         */
        WatermarkSessionUpdateEvent(uint32_t sessionHandle, uint32_t status, const std::string &system) : AAMPEventObject(AAMP_EVENT_WATERMARK_SESSION_UPDATE) , mSessionHandle(sessionHandle), mStatus(status), mSystem(system)
        {}

        /**
         * @brief WatermarkSessionUpdateEvent Destructor
         */
        virtual ~WatermarkSessionUpdateEvent() { }

        /**
         * @brief Get session handle
         *
         * @return session handle
         */
        uint32_t getSessionHandle() const { return mSessionHandle; }

	    /**
         * @brief Get session status 
         *
         * @return status
         */
        uint32_t getStatus() const { return mStatus; }

	/**
	 * @brief Get System
	 *
	 * @return System
	 */
	const std::string &getSystem() const { return mSystem; }
};

/**
 * @brief Class for the Content Protection Data Update Event on Dynamic Key Rotation
 */
class ContentProtectionDataEvent: public AAMPEventObject
{
	std::vector<uint8_t> mKeyID;                    /**< Key ID */
	std::string mStreamType;                /**< Stream Type */
public:
	ContentProtectionDataEvent() = delete;
	ContentProtectionDataEvent(const ContentProtectionDataEvent&) = delete;
	ContentProtectionDataEvent& operator=(const ContentProtectionDataEvent&) = delete;

	/*
	 * @brief ContentProtectionDataEvent Constructor
	 *
	 * @param[in] keyID - KeyID
	 * @param[in] streamType - Current StreamType
	 */

	ContentProtectionDataEvent(const std::vector<uint8_t> &keyID, const std::string &streamType);

	/**
	 * @brief ContentProtectionDataEvent Destructor
	 */
	virtual ~ContentProtectionDataEvent() { }
	/**
	 * @brief Get Current Key ID
	 *
	 * @return Current KeyID
	 */
	const std::vector<uint8_t> &getKeyID() const;

	/**
	 * @brief Get Current Stream Type
	 *
	 * @return Current StreamType
	 */
	const std::string &getStreamType() const;
};


using AAMPEventPtr = std::shared_ptr<AAMPEventObject>;
using MediaErrorEventPtr = std::shared_ptr<MediaErrorEvent>;
using SpeedChangedEventPtr = std::shared_ptr<SpeedChangedEvent>;
using ProgressEventPtr = std::shared_ptr<ProgressEvent>;
using CCHandleEventPtr = std::shared_ptr<CCHandleEvent>;
using MediaMetadataEventPtr = std::shared_ptr<MediaMetadataEvent>;
using BitrateChangeEventPtr = std::shared_ptr<BitrateChangeEvent>;
using TimedMetadataEventPtr = std::shared_ptr<TimedMetadataEvent>;
using BulkTimedMetadataEventPtr = std::shared_ptr<BulkTimedMetadataEvent>;
using StateChangedEventPtr = std::shared_ptr<StateChangedEvent>;
using SupportedSpeedsChangedEventPtr = std::shared_ptr<SupportedSpeedsChangedEvent>;
using SeekedEventPtr = std::shared_ptr<SeekedEvent>;
using TuneProfilingEventPtr = std::shared_ptr<TuneProfilingEvent>;
using BufferingChangedEventPtr = std::shared_ptr<BufferingChangedEvent>;
using DrmMetaDataEventPtr = std::shared_ptr<DrmMetaDataEvent>;
using AnomalyReportEventPtr = std::shared_ptr<AnomalyReportEvent>;
using WebVttCueEventPtr = std::shared_ptr<WebVttCueEvent>;
using AdResolvedEventPtr = std::shared_ptr<AdResolvedEvent>;
using AdReservationEventPtr = std::shared_ptr<AdReservationEvent>;
using AdPlacementEventPtr = std::shared_ptr<AdPlacementEvent>;
using MetricsDataEventPtr = std::shared_ptr<MetricsDataEvent>;
using ID3MetadataEventPtr = std::shared_ptr<ID3MetadataEvent>;
using DrmMessageEventPtr = std::shared_ptr<DrmMessageEvent>;
using BlockedEventPtr = std::shared_ptr<BlockedEvent>;
using ContentGapEventPtr = std::shared_ptr<ContentGapEvent>;
using HTTPResponseHeaderEventPtr = std::shared_ptr<HTTPResponseHeaderEvent>;
using WatermarkSessionUpdateEventPtr = std::shared_ptr<WatermarkSessionUpdateEvent>;
using ContentProtectionDataEventPtr = std::shared_ptr<ContentProtectionDataEvent>;
#endif /* __AAMP_EVENTS_H__ */

